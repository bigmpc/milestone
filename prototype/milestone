#!/bin/bash

current_version="v0.7.8"
location=~/.local/share/milestone
practice_location=~/.local/share/practices
source_file=~/.milestone
practice_tree=~/.practices
practice_history_file=~/.practice.history
practice_history_tree=~/.practice.tree
practice_file=$(date +%F).list
practice_map=/tmp/milestone/$(echo $(whoami))-practice.map;
daily_practice_list=/tmp/milestone/$(echo $(whoami))-practice-days.list;
cycle_map_file=/tmp/milestone/$(echo $(whoami))-cycle.map;
PREFERENCE_MONTH=$(date +%Y-%m);
PAIR_OPTION=false;
SHOW_HISTOGRAM=false;
COLORED=true; # can be disabled manually!
INSPECT=false;
PRACTICAL_HISTOGRAM=false;
MINIMUM_LIMIT=0;
MOJI=false;
FIRST_INDENT=true;
EASY_READ=false;
TODAY=$(date +%d);
now=$(date +%Fh%R | tr ':' '-');
vnow=$now;
sync_time() { now=$(date +%Fh%R | tr ':' '-'); }
custom_time() { vnow=$(date -d "$1" +%Fh%R | tr ':' '-'); }
custom_vtime() {
	vtime=$(echo "$1" | sed -r 's/(.*)h([0-9]*)-([0-9]*)$/\1 \2:\3/');
	vnow=$(date -d "$vtime" +%Fh%R | tr ':' '-');
}
daily_note=$now.note

MINIMUM_MONTHLY_DONE_PER_TASK=$(expr $TODAY \* 2 / 5);
AVERAGE_MONTHLY_DONE_PER_TASK=$(expr $TODAY \* 3 / 5);
HIGH_MONTHLY_DONE_PER_TASK=$(expr $TODAY \* 4 / 5);
if [ $MINIMUM_MONTHLY_DONE_PER_TASK -eq 0 ]; then MINIMUM_MONTHLY_DONE_PER_TASK=1; fi
if [ $AVERAGE_MONTHLY_DONE_PER_TASK -eq 0 ]; then AVERAGE_MONTHLY_DONE_PER_TASK=1; fi
if [ $HIGH_MONTHLY_DONE_PER_TASK -eq 0 ]; then HIGH_MONTHLY_DONE_PER_TASK=1; fi
DISPLAY_WIDTH=$(tput cols); # make histogram responsive on terminal!
MARK_DONE=false;
MARK_NOT_DONE=false;
INSPECT_OPTION=false;
REPRESENT_OPTION=false;
PREFERENCE_OPTION=false;
RESET_OPTION=false;
VERBOSE_OPTION=false;
ACTIVITY_OPTIONS=false;
SQUEEZE_OPTION=false;
SHOW_TASK_OPTION=false;
FORCE_UPDATE=false;
CHECK_UPDATE_OPTION=false;
UNINSTALL_OPTION=false;
#DISPLAY_WIDTH=18;
DISABLED_OPTION=false;
DAILY_REPORT=false;
PERIODICAL_HISTOGRAM=false;
max_cycle_length=3;
critical_tasks_per_day=3;
DOUBLE_INDENT=false;
FORCE_RESET=false;
CICLE_REPRESENTATION_OPTION=false;
REORDER_OPTION=false;
ring_list=
INCREMENT_PROGRESS=false;
DECREMENT_PROGRESS=false;
PRACTICES_OPTION=false;
DEBUG=false
SCORE_OPTION=false;
VERBOSE_OPTION=false;
LOOKUP_OPTION=false;
LOOKUP_TEXT=;
TABSIZE=4
TABSTRING=$(printf "%0.s\ " $(seq 1 $TABSIZE))
TABSTRING_ESCAPED=$(echo "$TABSTRING" | sed 's/\ /\\ /g')
WRITE_NOTE_OPTION=false;
CHECK_NOTE=false;

# color codes
DARK="\e[30m"
RED="\e[31m"
RED_ESCAPED="\\\e\[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
VIOLET="\e[35m"
CYAN="\e[36m"
GRAY="\e[37m"
LIGHT_GRAY="\e[1;30m"
DARK_GRAY="\e[1;90m"
ORANGE="\e[38;5;202m" # sometimes pink!
LIGHT_RED="\e[1;31m"
LIGHT_GREEN="\e[1;32m"
LIGHT_YELLOW="\e[1;33m"
LIGHT_BLUE="\e[1;34m"
LIGHT_VIOLET="\e[1;35m"
LIGHT_CYAN="\e[1;36m"
UNCOLOR="\e[39m"
DEFAULT="\e[39m\e[49m\e[0m"
DEFAULT_ESCAPED="\\\e\[39m\\\e\[49m\\\e\[0m"
BOLD="\e[1m"
DIM="\e[2m"
RESET_BOLD="\e[21m"
BLINK="\e[5m"
BLINK_ESCAPED="\\\e\[5m"
STRIKE_THROUGH="\e[9m"
STRIKE_THROUGH_ESCAPED="\\\e\[9m"

usage() {
	echo -e $BOLD"** Milestone Prototype **"$DEFAULT
	echo
	echo -e "General Options"
	echo
	echo "-h, --help        show help"
	echo "-r, --reorder     reorder cycle"
	echo "-v, --version     show program version"
	echo "--debug           enable debugging option"
	echo "--uninstall       uninstall milestone"
	echo
	echo "Practice Options"
	echo
	echo "-p, --practices   begin practicing"
	echo "-l, --lookup      lookup practice title and continue"
	echo "-s, --score       score last practice"
	echo "-w, --write-note  write daily note objectives"
	echo "-n <n>, --noted   check note, makes note disappear"
	echo "--tab             adjust tab size, default=4"
	echo
	echo "Editing Options"
	echo
	echo "-d <n>            mark as done"
	echo "-d+ <n>           mark as done and increment progress"
	echo "-D <n>            mark as not done"
	echo "-D+ <n>           mark as not done and decrement progress"
	echo
}

# gets file as first parameter
show_practices() {
	while read practice; do
		checked=$(echo "$practice" | grep -o '\-\-' | wc -l);
		practice_number=$(echo "$practice" | cut -d'	' -f1 | sed -r 's/^.*[^0-9]([0-9]*)$/\1/');
		practice_title=$(echo "$practice" | cut -d'	' -f2);
		practice_info=$(grep -B1 "$practice_title" $source_file | head -n1 | grep '#[^a-zA-Z+#]');

		if test -n "$practice_info"; then
			informative=true;
		else
			informative=false;
		fi

		practice_info=$(echo $practice_info | sed 's/^#[\ !?0-9]\ *//');
		if $informative && test -n "$practice_info"; then
			practice_unit=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\1/' | grep -v '#');
			practice_progress=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\2/' | grep -v '#');
			practice_total=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\3/' | grep -v '#');

			# if all resources are used, or complete is specified
			if [ "$practice_unit" == "complete" ]; then
				percentage=100;
			else
				percentage=$(expr $practice_progress \* 100 / $practice_total);
			fi

			if [ $percentage -eq 100 ]; then
				progress="$LIGHT_VIOLET";
			else
				progress="$VIOLET";
			fi

			if [ $percentage -eq 100 ]; then
				progress="$progress (complete)$DEFAULT";
			else
				progress="$progress ($percentage% - $practice_unit $practice_progress of $practice_total)$DEFAULT";
			fi
		else
			practice_unit=;
			practice_progress=;
			practice_total=;
			progress=
		fi

		if [ $checked -gt 0 ]; then
			bash_seq="$COLOR_OF_DAY$STRIKE_THROUGH";
		else
			bash_seq=;
		fi

		printf "%6s\t" $practice_number;
		echo -e "$bash_seq$practice_title$DEFAULT$progress";

	done <<< $(cat $1) | column;
	echo;
}

represent() {
	make_practice;
	echo -e $CYAN"Daily Progress"$DEFAULT; echo;
	TOTAL_TASKS=$(cat /tmp/$practice_file | sed '/^\ *$/d' | grep -v "#" | wc -l);
	DONE_COUNT=$(grep -o "\-\-" /tmp/$practice_file | wc -l | cut -d' ' -f1);
	MINIMUM_DONE=$(expr $TOTAL_TASKS / 4);
	MEDIUM_DONE=$(expr $TOTAL_TASKS \* 3 / 5);
	ESCAPED_DEFAULT="\\\e\[0m";
	COLOR_OF_DAY=$LIGHT_GREEN;

	show_practices /tmp/$practice_file
}

write_daily_note() {
	echo -e $BLUE"Write note per line and terminate by ^C+D"$DEFAULT; echo;
	note_counter=0
	if [ -f $location/daily_note ]; then
		sed -i 'd' $location/daily_note
	fi

	while IFS= read -r line; do
		echo "$line" >> $location/daily_note
		((++note_counter))
	done

	echo -e $GREEN"$note_counter notes saved."$DEFAULT; echo;
}

show_daily_note() {
	echo -e $LIGHT_CYAN"Daily Notes"$DEFAULT; echo;

	if [ -f $location/daily_note ]; then
		nl $location/daily_note | column
	fi
	echo
}

check_note() {
	if [ $note_number -gt $(wc -l $location/daily_note | cut -d' ' -f1) ]; then
		echo -e $BOLD"Note number out of range"$DEFAULT;
		return
	fi

	note=$(nl $location/daily_note | sed -n "${note_number}p" | cut -d'	' -f2)
	echo -e "The note <$LIGHT_YELLOW$note$DEFAULT> is$GREEN checked$DEFAULT";
	sed -i "${note_number}d" $location/daily_note
}

show_cycle() {
	sync_time;
	custom_vtime $cycle_start_time;
	first_cycle_day=$(date +%s -d "$vtime");
	if [ "$cycle_end_time" == "future" ]; then
		custom_vtime $now;
		last_cycle_day=$(date +%s -d "$vtime");
	else
		custom_vtime $cycle_end_time;
		last_cycle_day=$vtime;
	fi
	last_cycle_day=$(date +%s -d "$vtime");
	cycle_day=$(echo "(($last_cycle_day - $first_cycle_day) / 60 / 60 / 24) + 1" | bc);
	TOTAL_TASKS=$(cat $location/$cycle_file | sed '/^\ *$/d' | wc -l);
	DONE_COUNT=$(grep -o "\-\-" $location/$cycle_file | wc -l);
	cycle_percentage=$(expr $DONE_COUNT \* 100 \/ $TOTAL_TASKS);
	MINIMUM_DONE=$(expr $TOTAL_TASKS / 4);
	MEDIUM_DONE=$(expr $TOTAL_TASKS \* 3 / 5);
	ESCAPED_DEFAULT="\\\e\[0m";
	COLOR_OF_DAY=$LIGHT_GREEN;

	echo -e $LIGHT_CYAN"Cycle $cycle_number$DEFAULT$CYAN - $cycle_percentage% (day $cycle_day)"$DEFAULT; echo;

	# show ring of current cycle
	for ring_file in $ring_list; do
		ring_number=$(echo $ring_file | sed -r 's/.*ring([0-9]*).*/\1/');
		ring_start_day=$(echo $ring_file | sed -r 's/^.*ring[0-9]*_(.*)_(.*).list$/\1/');
		ring_end_day=$(echo $ring_file | sed -r 's/^.*ring[0-9]*_(.*)_(.*).list$/\2/');
		if test "$ring_end_day" == "future"; then sync_time; ring_end_day=$now; fi;

		custom_vtime $ring_start_day;
		ring_start_day=$(date +%s -d "$vtime");
		custom_vtime $ring_end_day;
		ring_end_day=$(date +%s -d "$vtime");
		ring_day=$(echo "(($ring_end_day - $ring_start_day) / 60 / 60 / 24) + 1" | bc);
		ring_total=$(cat $location/$ring_file | sed '/^\ *$/d' | wc -l);
		ring_done=$(grep -o "\-\-" $location/$ring_file | wc -l);
		ring_percentage=$(expr $ring_done \* 100 \/ $ring_total);

		echo -e $LIGHT_CYAN"    Ring $ring_number$DEFAULT$CYAN - $ring_percentage%"$DEFAULT; echo;
		show_practices $location/$ring_file
	done
}

show_disabled_goals() {
	echo -e $CYAN"Disabled Goals"$DEFAULT; echo;
	cat $source_file | grep -E "^#[^#+\!\ ]" | cut -d'#' -f2- | sort | nl | column
}

mark_done() {
	PRACTICE_NUMBER=$1;
	MIN_NUMBER=1;
	MAX_NUMBER=$(cat $location/$cycle_file | cut -d'	' -f1 | sed 's/^--//' | sort -n | tail -n1 | xargs)
	record=$(grep -E "^-?-?\ *.*[^0-9]$PRACTICE_NUMBER\	.*$" $(echo $ring_list | tr ' ' '\n' | sed s,^,$location\/, | xargs));
	record_file=$(echo $record | cut -d':' -f1);
	if test "$(echo $record | cut -d':' -f2 | cut -d' ' -f1)" == "--"; then already_done=true; else already_done=false; fi
	practice_title=$(echo $record | cut -d':' -f2 | sed 's/^\-\-\ //' | xargs | cut -d' ' -f2- | sed 's/\ *(.*)//');

	if [ $PRACTICE_NUMBER -ge $MIN_NUMBER ] && [ $PRACTICE_NUMBER -le $MAX_NUMBER ]; then
		if $already_done && ! $INCREMENT_PROGRESS; then
			echo -e $BOLD"Already marked$DEFAULT <$LIGHT_YELLOW$practice_title$DEFAULT> as$BOLD done$DEFAULT";
		else
			if $INCREMENT_PROGRESS; then
				echo -e "Marking$GREEN more progress$DEFAULT on <$LIGHT_YELLOW$practice_title$DEFAULT>"
			else
				echo -e "Marking <$LIGHT_YELLOW$practice_title$DEFAULT> as$GREEN done$DEFAULT"
			fi

			if $PREFERENCE_OPTION; then echo -e " on $CYAN$PRACTICE_DATE$DEFAULT"; else echo; fi
			sed -i -r s,^.*[^0-9]$PRACTICE_NUMBER[^0-9]\(.*\)$,"$(printf "\-\-%4s" $PRACTICE_NUMBER)"\\\t\\\1, /tmp/$practice_file;
			sed -i -r s,^\ \ \(\ *$PRACTICE_NUMBER\)[^0-9]\([^#]\),--\\\1\	\\\2, $location/$cycle_file;
			sed -i -r s,^\ \ \(\ *$PRACTICE_NUMBER\)[^0-9]\([^#]\),--\\\1\	\\\2, $record_file;

			if $INCREMENT_PROGRESS; then
				practice_info=$(grep -B1 "$practice_title" $source_file | head -n1 | grep '#[^a-zA-Z+#]' | sed 's/^#[\ !?0-9]\ *//');
				if test -n "$practice_info"; then
					practice_unit=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\1/' | grep -v '#');
					practice_progress=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\2/' | grep -v '#');
					practice_total=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\3/' | grep -v '#');
					if [ "$practice_unit" == "complete" ] || [ $(expr $practice_progress + 1) -gt $practice_total ]; then
						echo -e "You finished current resource of <$LIGHT_YELLOW$practice_title$DEFAULT>";
						return;
					fi
					sed -i -rz "s/$practice_unit\ *$practice_progress\ *\/\ *$practice_total(\n$practice_title)/$practice_unit\ $(expr $practice_progress + 1)\/$practice_total\1/" $source_file;
				fi
			fi
		fi
	else
		echo "Incorrect practice number";
		return;
	fi

}

mark_not_done() {
	PRACTICE_NUMBER=$1;
	MIN_NUMBER=0;
	MAX_NUMBER=$(cat $location/$cycle_file | cut -d'	' -f1 | sed 's/^--//' | sort -n | tail -n1 | xargs)
	RECORD=$(grep -E "^[^#]" $source_file | sort | sed '/^\ *$/d' | nl -bp^[^#] | grep -E "^\ *$PRACTICE_NUMBER[^0-9]\ *.*$" | xargs | sed 's/^\-\-\ //');
	PRACTICE_TITLE=$(echo "$RECORD" | cut -d' ' -f2-);
	record=$(grep -E "^-?-?\ *.*[^0-9]$PRACTICE_NUMBER\	$PRACTICE_TITLE$" $(echo $ring_list | tr ' ' '\n' | sed s,^,$location\/, | xargs));
	record_file=$(echo $record | cut -d':' -f1);
	practice_title=$(echo $record | cut -d':' -f2 | sed 's/^\-\-\ //' | xargs | cut -d' ' -f2- | sed 's/\ *(.*)//');
	if test "$(echo $record | cut -d':' -f2 | cut -d' ' -f1)" == "--"; then already_done=true; else already_done=false; fi

	if [ $PRACTICE_NUMBER -gt $MIN_NUMBER ] && [ $PRACTICE_NUMBER -le $MAX_NUMBER ]; then
		if ! $already_done && ! $DECREMENT_PROGRESS; then
			echo -e "Already marked <$LIGHT_YELLOW"$PRACTICE_TITLE"$DEFAULT> as$BOLD not done$DEFAULT";
		elif ! $DECREMENT_PROGRESS; then
			echo -e "Marking <$LIGHT_YELLOW"$PRACTICE_TITLE"$DEFAULT> as$BOLD not done$DEFAULT"
			if $PREFERENCE_OPTION; then echo -e " on $CYAN$PRACTICE_DATE$DEFAULT"; else echo; fi
			PRACTICE_TITLE=$(echo $PRACTICE_TITLE | sed 's/,/\\,/g');
			SUBSTITUTION=$(printf "%6s\t" $PRACTICE_NUMBER);
			sed -i s,--.*$PRACTICE_TITLE$,"$SUBSTITUTION$PRACTICE_TITLE", /tmp/$practice_file;
			sed -i s,--.*$PRACTICE_TITLE$,"$SUBSTITUTION$PRACTICE_TITLE", $location/$cycle_file;
			sed -i s,--.*$PRACTICE_TITLE$,"$SUBSTITUTION$PRACTICE_TITLE", $record_file;
		else
			echo -e $BOLD"Rolling back$DEFAULT progress on <$LIGHT_YELLOW"$PRACTICE_TITLE"$DEFAULT>"
		fi
	else
		echo "Incorrect practice number";
	fi

	## decrement progress unit if exists
if $DECREMENT_PROGRESS; then
	practice_info=$(grep -B1 -E "^$practice_title$" $source_file | head -n1 | grep '#[^a-zA-Z+#]' | sed 's/^#[\ !?0-9]\ *//');
	if test -n "$practice_info"; then
		practice_unit=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\1/' | grep -v '#');
		practice_progress=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\2/' | grep -v '#');
		practice_total=$(echo "$practice_info" | sed -r 's/^([a-zA-Z]*)\ ([0-9]*)\ *?\/\ *?([0-9]*).*$/\3/' | grep -v '#');
		if [ "$practice_unit" == "complete" ] || [ $(expr $practice_progress - 1) -lt 0 ]; then
			echo -e "Resources are already complete for <$LIGHT_YELLOW$practice_title$DEFAULT>";
			return;
		fi
		sed -i -rz "s/$practice_unit\ *$practice_progress\ *\/\ *$practice_total(\n$practice_title)/$practice_unit\ $(expr $practice_progress - 1)\/$practice_total\1/" $source_file;
	fi
fi

}

make_practice() {
	# check if today's practice file exists
	routine_task=false;
	while read line; do
		if [ "$line" == "#!" ]; then
				routine_task=true;
		elif $routine_task; then
				echo -e "$line-!";
				routine_task=false;
		elif [ $(echo $line | grep -oE "^[^#][^#+\-]" | wc -l) -gt 0 ]; then
				echo $line;
		else continue;
		fi;
	done <<< $(cat $source_file) | sort | nl | sed -r -e "s/^(\ *)(.*)-!$/\1$RED_ESCAPED\\\b!$DEFAULT_ESCAPED\2/" > /tmp/$practice_file;

	# make cycle
	routine_task=false;
	while read line; do
		if [ "$line" == "#!" ]; then
				routine_task=true;
		elif $routine_task; then
				echo -e "$line-!";
				routine_task=false;
		elif [ $(echo $line | grep -oE "^[^#][^#+]" | wc -l) -gt 0 ]; then
				echo $line;
		else continue;
		fi;
	done <<< $(cat $source_file) | sort | nl | sed -r -e "s/^(\ *)(.*)-!$/\1$RED_ESCAPED\\\b!$DEFAULT_ESCAPED\2/" > /tmp/$practice_file;
}

update_script() {
	echo -e "upgrading milestone, please wait!";
	cd /tmp
	if test -d milestone; then rm -rf milestone; fi
	echo -e "downloading source";
	git clone --depth 1 https://github.com/briansalehi/milestone.git &>/dev/null
	if [ $? -ne 0 ]; then echo -e $BOLD"failed to download the source"$DEFAULT; return; fi
	cd milestone
	./configure &>/dev/null
	make &>/dev/null
	if [ $? -eq 0 ]; then
		echo -e $GREEN"upgrade complete"$DEFAULT;
		exec $(which practices) -V
	else
		echo -e $BOLD"failed to upgrade"$DEFAULT;
	fi
}

uninstall_script() {
	# remove configuration files
	echo "backing up ~/.bashrc to ~/.bashbk"
	cp ~/.bashrc ~/.bashbk
	sed -i '/.*practices -z$/d' ~/.bashrc;
	if [ $(grep -Eo "export\ PATH\=.*\/.local\/bin" ~/.bashrc | wc -l) -gt 0 ]; then
		sed -i '/^export\ PATH\=.*\.local\/bin$/d' ~/.bashrc;
	fi
	echo "current PATH variable:";
	echo $PATH;
	PATH=$(echo $PATH | sed s,\:$HOME\/\.local\/bin,,);
	echo "new PATH variable:";
	echo $PATH;
	echo -e $BOLD"Milestone removed, changes will affect after next shell restart"$DEFAULT;
	echo -e "#!/bin/bash\nsleep 1;rm -f ~/.local/bin/practices;" > /tmp/milestone/milestone-remover.sh
	chmod +x /tmp/milestone/milestone-remover.sh
	exec /bin/bash /tmp/milestone/milestone-remover.sh &
	exit
}

sanity_check() {
	# garbage files storage
	if ! [ -d /tmp/milestone/ ]; then
		mkdir /tmp/milestone;
	fi

	# check if practices directoriy exists
	if ! [ -d $location ]; then
		mkdir -p $location;
	fi

	# check practice file
	if ! [ -f $source_file ]; then
		echo -e $BOLD"practice source does not exist, creating one."$DEFAULT;
		touch $source_file
		if [ $? -eq 0 ]; then
			echo -e $GREEN"~/.practices$DEFAULT file created";
		else
			echo -e $BOLD"failed to create $source_file"$DEFAULT;
		fi
	fi
}

# splits cycle into rings
# ring_file should be set properly before call
# cycle_number, cycle_start_time and cycle_end_time should be set properly
make_ring() {
	while read practice; do
		practice_number=$(echo "$practice" | cut -d'	' -f1 | sed -r 's/^.*[^0-9]([0-9]*)$/\1/');
		practice_title=$(echo "$practice" | cut -d'	' -f2);
		ring_number=$(grep -B1 -E "^$practice_title" $source_file | head -n1 | tr -d '#' | cut -d' ' -f1);
		ring_file=cycle$cycle_number\_ring$ring_number\_$cycle_start_time\_$cycle_end_time.list

		# make only specified ring, or make all rings
		# this might seem that the same thing always runs but it's not, think about it!
		if [ $# -eq 1 ] && [ $1 -eq $ring_number ]; then 
			printf "%6s\t%s\n" "$practice_number" "$practice_title" >> $location/$ring_file
		elif [ $# -eq 0 ]; then
			printf "%6s\t%s\n" "$practice_number" "$practice_title" >> $location/$ring_file
		fi
	done < /tmp/$practice_file
	if [ $? -ne 0 ]; then
		echo -e $BOLD"failed to create ring $ring_number"$DEFAULT
	fi
}

update_ring_list() {
	ring_list=$(find $location -type f -name "cycle$cycle_number\_ring*_future.list" -exec basename {} \; | sort | xargs);
	
}

reorder_cycle() {
	echo -e $BLUE"Reordering cycle and rings\n"$DEFAULT
	cycle_file=$(find $location -type f -name "cycle*.list" -exec basename {} \; | grep -v ring | sort | tail -n1);
	cycle_start_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\1/');
	cycle_end_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\2/');
	update_ring_list
	make_practice

	cat /tmp/$practice_file | cut -d'     ' -f2 > /tmp/milestone/newlist
	cat $location/$cycle_file | cut -d'     ' -f2 > /tmp/milestone/oldlist
while read practice; do
	practice_number=$(echo "$practice" | cut -d'	' -f1 | sed -r 's/^.*[^0-9]([0-9]*)$/\1/');
	practice_title=$(echo "$practice" | cut -d'	' -f2);
	ring_number=$(grep -B1 -E "^$practice_title" $source_file | head -n1 | tr -d '#' | cut -d' ' -f1);
	ring_file=cycle$cycle_number\_ring$ring_number\_$cycle_start_time\_$cycle_end_time.list;
	ring_list_with_path=$(echo $ring_list | tr ' ' '\n' | sed s,^,$location\/, | xargs);
	record=$(grep -H "$practice_title" $ring_list_with_path);
	record_state=$(echo $record | cut -d':' -f2 | cut -d' ' -f1);
	if test "$record_state" == "--"; then practice_done=true; else practice_done=false; fi
	record_file=$(echo $record | cut -d':' -f1);
	new_record=

	if [ $(grep -o "$practice_title" $location/$cycle_file | wc -l) -ne 1 ]; then
		echo -e $GREEN"Adding $practice_title"$DEFAULT
		sed -i "/$practice_title/d" $record_file;
		if [ $? -ne 0 ]; then echo -e $BOLD"failed to remove practice"$DEFAULT; fi
		if $practice_done; then
			new_record=$(printf "%s%4s\t%s" "--" $practice_number "$practice_title");
		else
			new_record=$(printf "%6s\t%s" $practice_number "$practice_title");
		fi
		cp $location/$ring_file /tmp/ring.tmp
		echo "$new_record" >> /tmp/ring.tmp
		new_index=$(sed 's/^--/  /' /tmp/ring.tmp | sort -n | nl | grep "$practice_title" | cut -d'	' -f1 | xargs);
		source_length=$(wc -l $location/$ring_file | cut -d' ' -f1);
		if [ $new_index -gt $source_length ]; then
			echo "$new_record" >> $location/$ring_file;
			echo "$new_record" >> $location/$cycle_file;
		else
			sed -i "$new_index i \"$new_record" $location/$ring_file;
			sed -i "$new_index i \"$new_record" $location/$cycle_file;
		fi
		if [ $? -ne 0 ]; then echo -e $BOLD"failed to move practice"$DEFAULT; fi
		sed -i 's/^\"//' $location/$ring_file;
		sed -i 's/^\"//' $location/$cycle_file;
	fi
done < /tmp/$practice_file
}

make_cycle() {
# load latest cycle
latest_cycle=$(find $location -type f -name "cycle*.list" -exec basename {} \; | grep -v ring | sort | tail -n1);
if [ -f "$location/$latest_cycle" ]; then
	cycle_file=$latest_cycle;
	cycle_done_count=$(grep -E "^--" $location/$cycle_file | wc -l);
	cycle_total_tasks=$(wc -l $location/$cycle_file | cut -d' ' -f1);
	cycle_number=$(echo $cycle_file | sed -r 's/^.*cycle([0-9]*).*\.list$/\1/');
	cycle_start_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\1/');
	cycle_end_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\2/');
	update_ring_list;

	# cycle is complete, make another
	if [ $cycle_done_count -eq $cycle_total_tasks ]; then
		# close cycle
		sync_time;
		echo -e $BOLD"closing cycle $cycle_number$DEFAULT"
		mv $location/cycle$cycle_number\_$cycle_start_time\_future.list $location/cycle$cycle_number\_$cycle_start_time\_$now.list;

		# close rings
		for ring in $ring_list; do
			ring_number=$(echo $ring | sed -r 's/.*ring([0-9]*).*/\1/');
			ring_start_time=$(echo $ring | sed -r 's/^.*ring[0-9]*_(.*)_(.*)\.list$/\1/');
			ring_end_time=$(echo $ring | sed -r 's/^.*ring[0-9]*_(.*)_(.*)\.list$/\2/');
			echo -e $BOLD"closing ring $ring_number$DEFAULT";
			mv $location/$ring $location/cycle$cycle_number\_ring$ring_number\_$ring_start_time\_$now.list
		done

		# migrate to next cycle
		((cycle_number++));
		echo -e $BOLD"making cycle $cycle_number"$DEFAULT;
		sync_time;
		cycle_file=cycle$cycle_number\_$now\_future.list;
		cycle_number=$(echo $cycle_file | sed -r 's/^.*cycle([0-9]*).*\.list$/\1/');
		cycle_start_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\1/');
		cycle_end_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\2/');
		ring_file=cycle$cycle_number\_ring$ring_number\_$cycle_start_time\_$cycle_end_time.list

		#grep -E "^[^#]" $source_file | sort | nl > $location/$cycle_file

		echo -e $BOLD"making new ring set for cycle $cycle_number"$DEFAULT;
		make_ring;
		update_ring_list;
	fi

	# if ring does not exist, set ring name as now
	if test -z "$ring_list"; then
		echo -e $BOLD"making new ring set"$DEFAULT;
		cycle_number=$(echo $cycle_file | sed -r 's/^.*cycle([0-9]*).*\.list$/\1/');
		cycle_start_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\1/');
		cycle_end_time=$(echo $cycle_file | sed -r 's/^.*cycle[0-9]*_(.*)_(.*)\.list$/\2/');
		ring_number=1
		ring_file=cycle$cycle_number\_ring$ring_number\_$cycle_start_time\_$cycle_end_time.list
		ring_list=$ring_file
		make_ring
		update_ring_list;
	fi

	# will pass if no ring exists yet
	for ring_file in $ring_list; do
		ring_number=$(echo $ring_file | sed -r 's/.*ring([0-9]*).*/\1/');
		ring_done_count=$(grep -E "^--" $location/$ring_file | wc -l);
		ring_total_tasks=$(wc -l $location/$ring_file | cut -d' ' -f1);

		# if ring is complete, start over
		if [ $ring_done_count -eq $ring_total_tasks ]; then
			# close ring
			ring_start_time=$(echo $ring_file | sed -r 's/^.*ring[0-9]*_(.*)_(.*).list$/\1/');
			ring_end_time=$(echo $ring_file | sed -r 's/^.*ring[0-9]*_(.*)_(.*).list$/\2/');
			sync_time;
			echo -e $BOLD"closing ring $ring_number"$DEFAULT;
			mv $location/$ring_file $location/cycle$cycle_number\_ring$ring_number\_$ring_start_time\_$now.list

			ring_file=cycle$cycle_number\_ring$ring_number\_$now\_future.list
			make_ring $ring_number;
			update_ring_list;
		fi
	done

else # no cycle exists at all
	echo -e $BOLD"cycle file not found! making first cycle."$DEFAULT;
	sync_time;
	cycle_number=1;
	cycle_start_time=$now;
	cycle_end_time=future;
	cycle_file=cycle$cycle_number\_$cycle_start_time\_$cycle_end_time.list;
	grep -E "^[^#]" $source_file | sort | nl > $location/$cycle_file;
	make_ring;
	update_ring_list;
fi
}

backup_practices() {
zip_errors="""
unknown zip error
unexpected end of zip file.
a  generic error in the zipfile format was detected.  Processing may have completed successfully anyway; some broken zipfiles
zip was unable to allocate memory for one or more buffers during program initialization.
a severe error in the zipfile format was detected.  Processing probably failed immediately.
entry too large to be processed (such as input files larger than 2 GB when not using Zip64 or trying to read an existing  ar‐
invalid comment format
zip -T failed or out of memory
the user aborted zip prematurely with control-C (or similar)
zip encountered an error while using a temp file
read or seek error
zip has nothing to do
missing or empty zip file
error writing to a file
zip was unable to create a file to write to
bad command line parameters
zip could not open a specified file to read
zip was compiled with options not supported on this system
"""

	backup=$(date +%y-%m-%d)
	if [ -f $location/$backup.zip ]; then zip_option="-u"; fi
	backup_list=$(find $practice_location/ -mindepth 1 -maxdepth 1 -type d)
	if [ -n "$backup_list" ]; then
		echo "$backup_list" | zip -q -r $zip_option $location/$backup.zip -@
		ret=$?
		echo -ne $BLUE"Backing up previous practices: "$DEFAULT
		if [ $ret -eq 0 ]; then
			echo -e $GREEN"complete"$DEFAULT;
			echo -e $BLUE"File: $DEFAULT$location/$backup.zip";
			while read line; do filename=$(echo "$line" | cut -d' ' -f2); rm "$filename"; done < /tmp/score.log
			find $practice_location/ -type f -executable ! -name score.sh -exec rm -f {} \;
		else
			((ret++))
			echo -e $BOLD"failed"$DEFAULT
			echo -e $BLUE"Reason: "$DEFAULT$BOLD$(echo "$zip_errors" | cut -d: -f2 | awk "NR==$ret");
		fi
	else
		echo -e $BOLD"No practices found to backup"$DEFAULT;
	fi
	echo;
}

# coloring scheme
black=0
red=1
green=2
yellow=3
blue=4
magenta=5
cyan=6
white=7

result=
language_analyzer() {
	filepath=$1
	filename=${filepath##*/}
	file_extension=${filename##*.}
	line_count=$(wc -l "$filepath" | cut -d' ' -f1)

	# detect language from extension
	case $file_extension in
		md)
			language=Markdown
			language_color=$cyan
			;;
		[mM]akefile)
			language=Makefile
			language_color=$black
			;;
		asm)
			language=Assembly
			language_color=$blue
			;;
		c|h)
			language=C
			language_color=$magenta
			;;
		c++|cxx|cpp|hpp|hxx|cu)
			language=Cxx
			language_color=$red
			;;
		sh)
			language=Shell
			language_color=$green
			;;
		py)
			language=Python
			language_color=$blue
			;;
		html|htm)
			language=HTML
			language_color=$red
			;;
		tex)
			language=TeX
			language_color=$green
			;;
		js)
			language=JavaScript
			language_color=$yellow
			;;
		*)
			language=Other
			language_color=$white
			return
			;;
	esac

	# restore previous line count
	previous_count=$(awk -v language=$language 'BEGIN{ RS=":" } $1==language {print $2}' <<< "$result")

	# if the extension does not already exist in the result, add it
	if [ -z "$previous_count" ]; then
		previous_count=0;
		result="$language 0 $language_color:$result"
	fi

	# sum up the lines of this extension
	((line_count+=previous_count))
	result=$(echo "$result" | awk -v language="$language" -v count=$line_count 'BEGIN{RS=":"; ORS=":"} $1==language {$2=count} NF==3')
}

language_analyzer_result() {
	# sum up all line counts
	sum=$(awk 'BEGIN{RS=":"} {sum+=$2} END{print sum;}' <<< "$result")

	if [ $sum -eq 0 ]; then
		tput bold
		echo "no output"
		tput sgr0
		return
	fi

	# evaluage line counts in result
	# fixme
	result=$(echo "$result" | sed 's/:$//')
	result=$(echo "$result" | awk -v sum=$sum 'BEGIN{RS=":"} {percentage=$2*100/sum; printf "%s %.1f %s\n", $1, percentage, $3}')

	# sort the languages based on percentage
	result=$(echo "$result" | tr ':' '\n' | sort -k2 -r -h | sed '/^$/d' | tr '\n' ':')

	# put the Other languages at the end if there are
	other=$(awk 'BEGIN{RS=":"} $1=="Other"' <<< "$result")
	if [ -n "$other" ]; then
		#result=$(echo "$result" | tr ':' '\n' | sed "/$other/d;\$a$other" | tr '\n' ':')
		result=$(echo "$result" | tr ':' '\n' | sed "/$other/d" | tr '\n' ':')
	fi

	echo -e $BLUE"Languages"$DEFAULT
	echo

	# draw the colored block line
	axis_length=40
	while FS= read -r line; do
		language=$(cut -d' ' -f1 <<< "$line")
		percentage=$(cut -d' ' -f2 <<< "$line")
		color=$(cut -d' ' -f3 <<< "$line")
		line_length=$(echo "$percentage * $axis_length / 100" | bc)
		tput setaf $color
		printf "%0.s\u2588" $(seq 1 $line_length)
		tput sgr0
	done <<< $(echo "$result" | tr ':' '\n' | sed '/^$/d')
	echo
	echo

	# write language names
	while FS= read -r line; do
		language=$(cut -d' ' -f1 <<< "$line")
		percentage=$(cut -d' ' -f2 <<< "$line")
		color=$(cut -d' ' -f3 <<< "$line")
		line_length=$(echo "$percentage * $axis_length / 100" | bc)
		tput setaf $color
		echo -ne "\u25cf "
		tput sgr0
		echo -n "$language "
		tput dim
		echo $percentage
		tput sgr0
	done <<< $(echo "$result" | tr ':' '\n' | sed '/^$/d')
}

# destination directory should be set as $1
language_graph() {
	# make function accessible globally
	export -f language_analyzer

	# search files and add them to results
	find $1 -type f -not -path '*/\.*' -not -executable > /tmp/language_analyzer
	while FS= read -r file; do
		language_analyzer "$file"
	done < /tmp/language_analyzer

	# output the result
	language_analyzer_result
}

score_practice() {
if ! [ -d $practice_location ]; then
	echo -e $BOLD"practice directory does not exist, creating"$DEFAULT
	mkdir -p $practice_location
fi

## remove swap files
find $practice_location/ -type f -name *~ -exec rm -f {} \;

# list practice files
find $practice_location/ -type f ! -executable ! -name *.sh ! -name *.zip ! -name *~ ! -name ".*~" ! -name *.swp> /tmp/score.log
score_files=$(wc -l /tmp/score.log | cut -d' ' -f1)

if [ $score_files -eq 0 ]; then
	echo -e $BLUE"Score: 0"$DEFAULT
elif [ $score_files -eq 1 ]; then
	only_score=$(wc -l $(cat /tmp/score.log))
	score=$(echo $only_score | cut -d' ' -f1)
	score_file=$(echo $only_score | cut -d' ' -f2-)
	echo -e $BLUE"Score: $score"$DEFAULT
	echo -e $BLUE"File: $score_file"$DEFAULT
elif $VERBOSE_OPTION && [ $score_files -gt 1 ]; then
	score=$(wc -l $(cat /tmp/score.log) | grep total)
	echo -e $BLUE"Score: $score "$DEFAULT
	echo -e $BLUE"Files: "$DEFAULT
	wc -l $(cat /tmp/score.log)
else
	score=$(wc -l $(cat /tmp/score.log) | grep total)
	echo -e $BLUE"Score: $score "$DEFAULT
fi

echo
language_graph $(readlink $practice_location)
}

daily_practice() {
# load from history
if $RESET_OPTION
then
	backup_practices
	if [ -f $practice_history_file ]
	then
		rm $practice_history_file
	fi
	if [ -f $practice_history_tree ]
	then
		rm $practice_history_tree
	fi
fi

if $LOOKUP_OPTION && [ -n "$LOOKUP_TEXT" ]; then
	match=$(grep -Ei "^$LOOKUP_TEXT.*" $practice_tree)
	match_counter=$(echo "$match" | grep -oE '^[^\t]' | wc -l)

	if [ $match_counter -eq 0 ]; then
		echo -e $BOLD"No match found for \"$LOOKUP_TEXT\""$DEFAULT
		return
	elif [ $match_counter -gt 1 ]; then
		echo -e $BOLD"Match ambiguity, choose:"$DEFAULT
		echo "$match" | nl
		read choice
		match=$(echo "$match" | awk "NR == $choice")
	fi

	if [ -n "$match" ]; then
		line_counter=$(awk "/$match/{ print NR; exit }" $practice_tree)
	fi

elif [ -f $practice_history_file ] && ! $RESET_OPTION; then
	line_counter=$(cat $practice_history_file);
	if [ -f $practice_history_tree ]
	then
		sed "s/\t/$TABSTRING/g" $practice_history_tree
	fi
else
	line_counter=0;
fi

skipped_flag=false
while IFS= read -r line
do
	linedepth=$(echo "$line" | grep -oP "\t" | wc -l)
	topic=$(echo "$line" | grep -oP "^[^\t]" | wc -l)
	nextline=$(grep -A1 -E "^$line$" $practice_tree 2>/dev/null | sed 1d)
	nextdepth=$(echo "$nextline" | grep -oP "\t" | wc -l)
	nexttopic=$(echo "$nextline" | grep -oP "^[^\t]" | wc -l)
	line=$(echo "$line" | sed "s/^\t/$TABSTRING/g")

	# make history
	echo $line_counter > $practice_history_file;

	if [ -f $practice_history_tree ]
	then
		historydepth=$(tail -n1 $practice_history_tree | grep -oP "\ \ " | wc -l);
		if $DEBUG; then echo -e $BOLD"***\nremoving lines with depth $linedepth"$DEFAULT; fi
		if $DEBUG; then sed -n "/$(printf "%0.s$TABSTRING" $(seq 0 $linedepth))/p" $practice_history_tree; fi
		if $DEBUG; then echo -e $BOLD"***"$DEFAULT; fi

		if [ $linedepth -eq 0 ]; then
			sed -i 'd' $practice_history_tree
		elif [ $linedepth -le $historydepth ]; then
			sed -i "/$(printf "%0.s$TABSTRING_ESCAPED" $(seq 0 $(expr $linedepth - 1)))/d" $practice_history_tree
		fi
	fi

	# consequitive root levels are ignored
	if [ $topic -eq 1 ] && [ $nexttopic -eq 1 ]
	then
		((++line_counter));
		continue
	# next main topic
	elif [ $topic -eq 1 ] && [ $nexttopic -eq 0 ]
	then
		if [ -f $practice_history_tree ]
		then
			rm $practice_history_tree
		fi

		if $DEBUG; then echo -n $linedepth+$nextdepth; fi
		echo -e $LIGHT_BLUE"$line"$DEFAULT | tee -a $practice_history_tree
	# deeper topic
	elif [ $topic -eq 0 ]
	then
		# next non-zero level topic
		if [ $nextdepth -gt $linedepth ]
		then
			if $DEBUG; then echo -n $linedepth+$nextdepth; fi
			echo -e "$line" | sed "s/\t/$TABSTRING/g" | tee -a $practice_history_tree
		# deepest topic
		elif [ $nextdepth -lt $linedepth ]
		then
			if $DEBUG; then echo -n $linedepth $nextdepth; fi
			echo -en $(tput bold)"$line" |\
			   	sed -r -e "s/\t/$TABSTRING/g"\
				-e "s/(\([^\)]*)\[(depricate|obsolete|obsolescence)([^,\)]*)/\1$(tput dim)\[\2\3$(tput sgr0)$(tput bold)/"\
				-e "s/([^\(]*)\[(depricate|obsolete|obsolescence)([^\n]*)/\1$(tput dim)\[\2\3$(tput sgr0)$(tput bold)/"\
				-e "s/(,[^,]*)\[(depricate|obsolete|obsolescence)([^,]*)/\1$(tput dim)\[\2\3$(tput sgr0)$(tput bold)/"\
				&& tput sgr0
			if [ $(echo "$line" | grep -Eo ",$" | wc -l) -eq 1 ]; then
				echo
				skipped_flag=true
				continue
			else
				if $skipped_flag; then ((++line_counter)); skipped_flag=false; fi
				if $DEBUG; then echo -n " line: $line_counter"; fi
				read input < /dev/tty
			fi
		fi
	fi

	((++line_counter));
done <<< $(tail -n +$line_counter $practice_tree)

if [ -f $practice_history_file ]; then
	rm $practice_history_file;
fi
}

parse_option() {
	case $1 in
	"-h"|"--help")
		ACTIVITY_OPTIONS=true;
		usage;
		return;
		;;
	"-d")
		ACTIVITY_OPTIONS=true;
		PAIR_OPTION=true;
		MARK_DONE=true;
		MARK_VALUE=$option_value;
		;;
	"-d+")
		ACTIVITY_OPTIONS=true;
		PAIR_OPTION=true;
		MARK_DONE=true;
		MARK_VALUE=$option_value;
		INCREMENT_PROGRESS=true;
		;;
	"-D-")
		ACTIVITY_OPTIONS=true;
		PAIR_OPTION=true;
		MARK_NOT_DONE=true;
		MARK_NOT_VALUE=$option_value;
		DECREMENT_PROGRESS=true;
		;;
	"-D")
		ACTIVITY_OPTIONS=true;
		PAIR_OPTION=true;
		MARK_NOT_DONE=true;
		MARK_NOT_VALUE=$option_value;
		;;
	"--reset")
		ACTIVITY_OPTIONS=true;
		RESET_OPTION=true;
		;;
	"-r"|"--reorder")
		REORDER_OPTION=true;
		;;
	"-s"|"--score")
		ACTIVITY_OPTIONS=true;
		SCORE_OPTION=true;
		;;
	"-p"|"--practices")
		ACTIVITY_OPTIONS=true;
		PRACTICES_OPTION=true;
		;;
	"-P"|"--preference")
		PAIR_OPTION=true;
		PREFERENCE_OPTION=true;
		PREFERENCE_VALUE=$option_value;
		;;
	"-v"|"--version")
		ACTIVITY_OPTIONS=true;
		echo $current_version;
		return;
		;;
	"-l"|"--lookup")
		PAIR_OPTION=true;
		LOOKUP_OPTION=true;
		LOOKUP_TEXT=$option_value;
		;;
	"-w"|"--write-note")
		ACTIVITY_OPTIONS=true;
		WRITE_NOTE_OPTION=true;
		;;
	"-n"|"--noted")
		ACTIVITY_OPTIONS=true;
		CHECK_NOTE=true;
		PAIR_OPTION=true;
		note_number=$option_value;
		;;
	"--tab")
		PAIR_OPTION=true;
		TABSIZE=$option_value;
		TABSTRING=$(printf "%0.s\ " $(seq 1 $TABSIZE))
		TABSTRING_ESCAPED=$(echo "$TABSTRING" | sed 's/\ /\\ /g')
		;;
	"--verbose")
		VERBOSE_OPTION=true;
		;;
	"--uninstall")
		ACTIVITY_OPTIONS=true;
		UNINSTALL_OPTION=true;
		return;
		;;
	"--debug")
		DEBUG=true;
		;;
	*)
		ACTIVITY_OPTIONS=true;
		usage;
		exit
		;;
	esac
}

if [ $# -eq 0 ]; then
	REPRESENT_OPTION=true;
else
option_value="";
while [ $# -gt 0 ]; do
	# treat option as if it requires value; only options that specify PAIR_OPTION; aka. -d 11
	if $PAIR_OPTION; then
		PAIR_OPTION=false; shift; continue;
	fi

	# if option is not long then treat as short joint options; aka. -d11
	if [ $(echo $1 | grep -Eo "^\-[a-zA-Z][a-zA-Z0-9].*$" | wc -l | cut -d' ' -f1) -gt 0 ]; then
		script_option=$(echo $1 | sed 's/^\-//');
		option_length=$(echo $script_option | wc -c);
		option_length=$(expr $option_length - 2);

		for option_index in $(seq 0 $option_length); do
			option_letter=$(echo ${script_option:$option_index:1});

			if $PAIR_OPTION; then
				if [ $(echo $option_letter | grep -Eo "^[0-9]$" | wc -l) -gt 0 ]; then
					option_value="$(echo $option_value$option_letter)";
					if [ $option_index -eq $option_length ]; then
						PAIR_OPTION=false;
						shift;
					else
						shift; continue;
					fi
				fi
				PAIR_OPTION=false;

				parse_option "-${script_option:0:1}" "$option_value";
			else
				parse_option "-${script_option:$option_index:1}" "$option_value";
				option_value=""
			fi
			((option_letter++)); # increment the pointer to next option character
		done # done shifting between option characters (multiple options)
	else # aka. --mark-done 11
		option_value=$2;
		parse_option $1 $option_value;
	fi
	shift
done # done shifting between arguments
fi

sanity_check
make_practice
make_cycle

if $PREFERENCE_OPTION; then
	if test -n "$PREFERENCE_VALUE"; then
		# check date
		PRACTICE_DATE=$(date +%Y-%m-%d -d "$PREFERENCE_VALUE");
		PREFERENCE_MONTH=$(date +%Y-%m -d "$PREFERENCE_VALUE");
		if [ $? -ne 0 ]; then exit; fi
		practice_file=$PRACTICE_DATE.list;
	else
		echo -e $BOLD"date not specified"$DEFAULT;
	fi
fi

if $SQUEEZE_OPTION; then
	DISPLAY_WIDTH=$(expr $DISPLAY_WIDTH / $SQUEEZE_VALUE);
fi

if $WRITE_NOTE_OPTION; then
	write_daily_note
fi

if $CHECK_NOTE; then
	check_note
fi

if $SCORE_OPTION; then
	score_practice;
fi

if $PRACTICES_OPTION; then
	trap "echo -e '\b\b\n'; score_practice; exit" SIGINT;
	daily_practice;
fi

if $INSPECT_OPTION; then
	if test -n "$INSPECT_VALUE"; then
		INDICATOR=$INSPECT_VALUE;
		INSPECT=true;
	else
		echo -e $BOLD"practice number needed to inspect but not given"$DEFAULT;
	fi
fi

if $MARK_DONE; then
	make_practice;
	if test -n "$MARK_VALUE"; then
		mark_done $MARK_VALUE;
	else
		echo "practice number not specified";
	fi
fi

if $MARK_NOT_DONE; then
	make_practice;
	if test -n "$MARK_NOT_VALUE"; then
		mark_not_done $MARK_NOT_VALUE;
	else
		echo "practice number not specified";
	fi
fi

if ! $SCORE_OPTION &&  $RESET_OPTION; then
	rm /tmp/$practice_file;
	make_practice;
fi

if $UNINSTALL_OPTION; then
	echo -ne $BOLD"Are you sure you want to remove milestone? "$DEFAULT;
	read response;
	if test "$response" = "y" || test "$response" = "yes"; then
		echo -ne $BOLD"Are you really sure? "$DEFAULT;
		read response2;
		if test "$response2" = "y" || test "$response2" = "yes"; then
			uninstall_script
		fi
	fi
fi

if $REORDER_OPTION; then
	make_practice
	reorder_cycle;
fi

if $CICLE_REPRESENTATION_OPTION && $ACTIVITY_OPTIONS; then
	show_daily_note
	show_cycle;
fi

if $REPRESENT_OPTION || ! $ACTIVITY_OPTIONS; then
	if $DISABLED_OPTION; then
		show_disabled_goals;
	elif $DAILY_REPORT; then
		represent;
	else
		show_daily_note
		show_cycle;
	fi
fi

# TODO:
# array of practice numbers for marking
# manage tasks (undone goals) and separate them from practices (done goals)
# link goals and get practices automatically based on goals
# progress based on time spent, not only practice count
# monthly report over practices count and time
