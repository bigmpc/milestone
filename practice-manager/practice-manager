#!/usr/bin/env bash

# terminates script executaion after call
function usage {
	echo "Practice Page Manager"
	echo
	tput bold
	echo "Options:"
	tput sgr0
	echo
	echo "  -r <path/to/file>     Remove practice or chapter"
	echo "  -f                    Force compile, regenerates all output files"
	echo
	tput bold
	echo "Usage:"
	tput sgr0
	echo
	tput setaf 7
	echo "  $ practice-manager"
	tput sgr0
	echo "                        Reads files and generates html-files"
	echo
	tput setaf 7
	echo "  $ practice-manager <source> <destination>"
	tput sgr0
	echo "                        Moves and/or renames practice and/or chapter"
	echo
	tput setaf 7
	echo "  $ practice-manager <path>"
	tput sgr0
	echo "                        Creates new chapter if there is no extension"
	echo "                        at the end of path (e.g. python/chapter1)"
	echo "                        or creates a practice page if extension"
	echo "                        given (e.g. python/chapter1/sample.py)"
	echo "                        If file already exists but not indexed,"
	echo "                        it will be joined and indexed in practices."
	echo "                        This is useful if you already have practice"
	echo "                        file from the past and have not joined them"
	echo "                        yet. (e.g. python/chapter1/old.py)"
}

# html line generators
###############################################################################

# requires path to page
# requires begin/end as second parameter
function generate_html_section {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
<!DOCTYPE html>
<html lang="en">
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</html>
EOF
	fi
}

# requires path to page
# requires begin/end as second parameter
function generate_html_head {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local title="${3:-$page}"
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
<title>${title}</title>
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</head>
EOF
	fi
}

# requires path to page
# requires header size
# requires title
function generate_html_header {
	local page="${1%.*}"
	page="${page##*/}"
	local size="${2:-1}"
	local title="${3:-header}"

	echo "<h${size}>$title</h${size}>" >> "./html-files/${index}.html"
}

# requires path to page
# optional style names [multiple names allowed]
function generate_html_style {
	local page="${1%.*}"
	page="${page##*/}"

	echo "<style>" >> "./html-files/${index}.html"

	cat << EOF >> "./html-files/${index}.html"
.dark-mode {
  background-color: black;
  color: #999;
}
EOF

	echo "</style>" >> "./html-files/${index}.html"
}

# requires path to page
# optional style names [multiple names allowed]
function generate_html_script {
	local page="${1%.*}"
	page="${page##*/}"

	echo "<script>" >> "./html-files/${index}.html"

	cat << EOF >> "./html-files/${index}.html"
function darkmode() {
	const hours = new Date().getHours()
	const isDayTime = hours > 6 && hours < 20
    if (!isDayTime) {
   		var bodystyle = document.body;
   		bodystyle.classList.toggle("dark-mode");
    }
}
darkmode();
EOF

	echo "</script>" >> "./html-files/${index}.html"
}

# requires path to page
# requires begin/end as second parameter
function generate_html_body {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
<body>
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
</body>
EOF
	fi
}

# requires path to page
# optional css style name
function generate_html_code {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local css_style="$3"
	local code_tag

	if [ -n "$css_style" ]
	then
		code_tag="<code class=\"${css_style}\">"
	else
		code_tag="<code>"
	fi

	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
<pre>
${code_tag}
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</code>
</pre>
EOF
	fi
}

# requires path to page
# optional begin/end
# optional css style name
function generate_html_div {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local css_style="$3"
	local div_tag

	if [ -n "$css_style" ]
	then
		div_tag="<div class=\"${css_style}\">"
	else
		div_tag="<div>"
	fi

	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
${div_tag}
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</div>
EOF
	fi
}

# requires path to page
function generate_html_break {
	echo "    <br />" >> "./html-files/${index}.html"
}

# requires path to page
# requires link
# requires title
function generate_html_link {
	local page="${1%.*}"
	page="${page##*/}"
	local link="${2:-#}"
	local title="${3:-link}"

	echo "<a href=\"$link\">$title</a>" >> "./html-files/${index}.html"
}

# requires path to page
# requies text
# optional command
function generate_html_text {
	local page="$1"
	local text="$2"
	local style="$3"
	local tag=

	if [ -n "$style" ]
	then
		tag="<p class=\"${style}\">"
	else
		tag="<p>"
	fi

	echo "${tag}${text}</p>" >> "./html-files/${index}.html"
}

# requires path to page
# optional begin/end
# optional css class
# optional css style
function generate_html_list {
	local page="$1"
	local side="${2:-begin}"
	local class="$3"
	local style="$4"
	local tag=

	if [ "$side" = "begin" ]
	then
		if [ -n "$class" ]
		then
			if [ -n "$style" ]
			then
				tag="<ul class=\"${class}\" style=\"${style}\">"
			else
				tag="<ul class=\"${class}\">"
			fi
		else
			tag="<ul>"
		fi

		echo "${tag}${text}" >> "./html-files/${index}.html"
	elif [ "$side" = "end" ]
	then
		echo "</ul>" >> "./html-files/${index}.html"
	fi
}

# requires path to page
# required text
# optional address
# optional class
function generate_html_item {
	local page="$1"
	local text="$2"
	local address="$3"
	local class="$4"
	local tag=
	local tag_end="</li>"

	if [ -n "$class " ]
	then
		tag="<li class=\"${class}\">"
	else
		tag="<li>"
	fi

	if [ -n "$address" ]
	then
		tag="${tag}<a href=\"${address}\">"
		tag_end="</a></li>"
	else
		tag_end="</li>"
	fi

	echo "${tag}${text}${tag_end}" >> "./html-files/${index}.html"
}

# required functions for managing practice pages
###############################################################################

# requires absolute path to source to configure corresponding variables
function update_configuration {
	local directory
	local config

	for level in ${1//\//$'\n'}
	do
		if [ -d "$directory$level" ]
		then
			directory="$directory$level/"
		elif [ -f "$directory$level" ]
		then
			directory="$directory${level%.*}"
		fi

		config="$directory.config"

		if [ -f "$config" ]
		then
			source "$config"
		fi
	done
}

# requires path to page
# requires compile/link/run option
# requires command
function generate_execution_mode {
	local page="${1}"
	local mode="${2:-compile}"
	local command="${3}"

	if [ -z "$command" ]
	then
		tput bold
		echo "execution command not specified: $page"
		tput sgr0
		return 1
	fi

	generate_html_header "$1" 4 "${mode}"
	generate_html_text "$1" "$command" command-style
}

# requires absolute path to source
# option headers and required files
function compile_source {
	update_configuration "$1"

	if [ "$EXECUTABLE" != "true" ]
	then
		return 2
	fi

	generate_html_header "$1" 2 "Execution"

	local binary="${1%.*}.bin"
	local object="${1%.*}.o"
	local headers="$@"
	headers="${headers/$1 }"
	local includes=
	local output="${1%.*}.output.txt"
	local execution_command
	local output_change_time
	local source_change_time

	if [ "$COMPILABLE" = "true" ] && [ -z "$COMPILER" ]
	then
		tput bold
		echo "compiler not specified for: $1" >&2
		tput sgr0
		return 1
	fi

	if [ "$INCLUDES" != "true" ]
	then
		headers=
	fi

	source_change_time=$(stat -c "%Y" "$1")

	if [ -f "$output" ]
	then
		output_change_time=$(stat -c "%Y" "$output")
	else
		output_change_time=0
	fi

	if ! [ -f "$output" ] || [ "$source_change_time" -ge "$output_change_time" ]
	then
		if [ "$COMPILABLE" = "true" ]
		then
			execution_command="$COMPILER $COMPILER_OPTIONS $object $1"
			if ! $execution_command
			then
				tput bold
				echo "compilation error: $1" >&2
				tput sgr0
				return 1
			fi
			generate_execution_mode "$1" compile "$execution_command"
		else
			if [ -f "$binary" ]
			then
				unlink "$binary"
			fi
			ln -s "$PWD/$1" "$binary"
		fi
	else
		if [ "$COMPILABLE" = "true" ]
		then
			execution_command="$COMPILER $COMPILER_OPTIONS ${object##*/} ${1##*/}"
			generate_execution_mode "$1" compile "$execution_command"
		fi
	fi

	execution_command="$LINKER $LINKER_OPTIONS $binary $object $headers"

	if ! [ -f "$output" ] || [ "$source_change_time" -ge "$output_change_time" ]
	then
		if [ "$COMPILABLE" = "true" ] && [ -n "$LINKER" ]
		then
			if ! $execution_command
			then
				tput bold
				echo "linkage error for: $1" >&2
				tput sgr0
				return 1
			fi
		elif [ "$COMPILABLE" = "true" ] && [ -z "$LINKER" ]
		then
			tput bold
			echo "linker not specified for: $1" >&2
			tput sgr0
			return 1
		fi
	fi

	if [ "$COMPILABLE" = "true" ]
	then
		binary="${binary##*/}"
		object="${object##*/}"
		for header in $headers
		do
			includes+="$header "
		done

		execution_command="$LINKER $LINKER_OPTIONS $binary $object $includes"
		generate_execution_mode "$1" link "$execution_command"
	fi
}

# requires path to page
# optional floor to start indexing directories
# sets page_index and page_hierarchy variables
function index_page {
	local floor="${2:-1}"

	local depth=1
	local entry=
	local hierarchy=
	local index=
	page_index=
	page_hierarchy=

	for entry in ${1//\//$'\n'}
	do
		hierarchy="${hierarchy:-$entry}"

		if [ "$depth" -gt "$floor" ]
		then
			match="$(grep -n "$entry" "${hierarchy}/.index")"
			match="${match%%:*}"
			match="${match%% *}"
			((match--)) # shift index down because of readme indexes
			index+="${match}."
		fi

		((depth++))
		hierarchy="${hierarchy}/${entry}"
	done
	page_index="${index%.}"
	page_hierarchy="${hierarchy#\.\/}"
}

# requires path to page
# optional up/down for direction of growth
# sets deepest_page variable
function deepest_path {
	local hierarchy="${1%/}"
	local direction="${2:-up}"

	local entry=
	local tool=
	deepest_page=

	if [ "$direction" = "up" ]
	then
		tool="head"
	elif [ "$direction" = "down" ]
	then
		tool="tail"
	else
		return 1
	fi

	while true
	do
		if [ -d "$hierarchy" ] && [ -f "${hierarchy}/.index" ]
		then
			entry="$("$tool" -n1 "${hierarchy}/.index")"
			entry="${entry%% *}"
			if [ -n "$entry" ]
			then
				hierarchy="${hierarchy}/${entry}"
			else
				break
			fi
		else
			break
		fi
	done
	deepest_page="$hierarchy"
}

# requires path to page
# optional up/down for direction of growth
# sets page_index and page_hierarchy variables
# note: empty variables means there is no neighbor
function nearest_path {
	local hierarchy="${1%/}"
	local page="${hierarchy##*/}"
	hierarchy="${hierarchy%/*}"
	local direction="${2:-up}"
	local match=
	local option=

	if [ "$direction" = "up" ]
	then
		option="-B1"
	elif [ "$direction" = "down" ]
	then
		option="-A1"
	else
		return 1
	fi

	while [ "$hierarchy" != "." ]
	do
		match="$(grep "$option" "$page" "${hierarchy}/.index")"

		if [ "$direction" = "up" ]
		then
			match="${match%$'\n'*}"
		else
			match="${match#*$'\n'}"
		fi
		match="${match%% *}"

		if [ "$match" = "$page" ]
		then
			page="${hierarchy##*/}"
			hierarchy="${hierarchy%/*}"
		else
			if [ "$direction" = "up" ]
			then
				direction="down"
			else
				direction="up"
			fi

			if [ -d "${hierarchy}/${match}" ]
			then
				deepest_path "${hierarchy}/${match}" "$direction"
				page="$deepest_page"
			else
				page="${hierarchy}/${match}"
			fi

			index_page "$page"
			break
		fi
	done

	if [ "$hierarchy" = "." ]
	then
		page_index=
		page_hierarchy=
	fi
}

# functions to generate html pages
###############################################################################

# requires path to page
function generate_breadcrumb_section {
	local hierarchy=
	local entry=
	local page=
	local title=
	local local_index=

	echo "<ul class=\"breadcrumb\">" >> "./html-files/${index}.html"

	for entry in ${1//\//$'\n'}
	do
		if [ -z "$hierarchy" ]
		then
			hierarchy="$entry"
			continue
		fi

		hierarchy="${hierarchy}/${entry}"

		if [ -d "$hierarchy" ] && [ -f "${hierarchy}/README.title.txt" ]
		then
			if [ "${hierarchy}/README.md" != "$1" ]
			then
				title="$(cat "${hierarchy}/README.title.txt")"
				local_index="$hierarchy"
				local_index="${local_index//[^\/]/}"
				local_index="${#local_index}"
				page="$(echo "$page_index" | cut -d"." -f1-"$local_index").0.html"
				echo "<li><a href=\"${page}\">${title:-"..."}</a></li>" >> "./html-files/${index}.html"
			fi
		elif [ -f "$hierarchy" ] && [ -f "${hierarchy%.*}.title.txt" ]
		then
			title="$(cat "${hierarchy%.*}.title.txt")"
			echo "<li class=\"active\">${title:-"..."}</li>" >> "./html-files/${index}.html"
		else
			tput bold
			echo "untitled breadcrumb: ${hierarchy}"
			tput sgr0
			echo "<li>...</li>" >> "./html-files/${index}.html"
		fi
	done

	echo "</ul>" >> "./html-files/${index}.html"
}

function generate_index_section {
	local tag="<h1>"

	echo -n "  ${tag}${index}. " >> "./html-files/${index}.html"
}

# requires path to page
function generate_header_section {
	local page="${1%.*}"
	local header="$page.title.txt"
	page="${page##*/}"
	local title

	if ! [ -f "$header" ]
	then
		tput bold
		echo "header not found: $header" >&2
		tput sgr0
	elif [ -z "$(cat "$header")" ]
	then
		tput bold
		echo "empty header: $header" >&2
		tput sgr0
	else
		title="$(cat "$header")"
		generate_html_header "$1" 1 "$title"
	fi
}

# requires path to page
function generate_page_name {
	local tag="<cite>"
	local tag_end="</cite>"

	echo "  ${tag}${1##*/}${tag_end}" >> "./html-files/${index}.html"
	echo "  <hr />" >> "./html-files/${index}.html"
}

# requires path to page
function generate_source_section {
	update_configuration "$1"

	if [ "$SOURCE" != "true" ]
	then
		return 1
	fi

	generate_html_header "$1" 2 "Source"
	while [ $# -gt 0 ]
	do
		generate_page_name "${1}"
		generate_html_code "$1" begin
		OLD_IFS="$IFS"
		IFS=
		local line
		while read -r line
		do
			line="${line//&/&amp;}"
			line="${line//\"/&quot;}"
			line="${line//\'/&apos;}"
			line="${line//</&lt;}"
			line="${line//>/&gt;}"
			echo "    $line" >> "./html-files/${index}.html"
		done < "$1"
		IFS="$OLD_IFS"
		generate_html_code "$1" end
		shift
	done
}

# requires absolute path to page
function generate_output_section {
	local page="${1%.*}"
	local binary="$page.bin"
	local output="$page.output.txt"
	local input="$page.input.txt"
	page="${page##*/}"

	if ! compile_source $@
	then
		return 1
	fi

	if ! [ -f "$binary" ]
	then
		tput bold
		echo "binary file not generated: $binary" >&2
		tput sgr0
		return 1
	fi

	if [ "$COMPILABLE" = "true" ]
	then
		if [ -f "$input" ]
		then
			"$binary" < "$input" > "$output"
		else
			"$binary" > "$output"
		fi
		generate_execution_mode "$1" run "./${binary##*/}"
	else
		if [ -f "$input" ]
		then
			"$COMPILER" "$binary" < "$input" > "$output"
		else
			"$COMPILER" "$binary" > "$output"
		fi
		generate_execution_mode "$1" run "$COMPILER ${1##*/}"
	fi
	echo >> "$output"

	local line
	if [ -f "$input" ]
	then
		echo "  <h2>Input</h2>" >> "./html-files/${index}.html"

		generate_html_div "$1" begin input-style
		while read -r line
		do
			echo "   $line" >> "./html-files/${index}.html"
		done < "$input"
		generate_html_div "$1" end
	fi

	echo "  <h2>Output</h2>" >> "./html-files/${index}.html"

	generate_html_div "$1" begin output-style
	if ! [ -f "$output" ]
	then
		tput bold
		echo "output file not found: $output" >&2
		tput sgr0
	else
		while read -r line
		do
			echo "   $line" >> "./html-files/${index}.html"
		done < "$output"
	fi
	generate_html_div "$1" end
}

# requires absolute path to page
function generate_comment_section {
	update_configuration "$1"

	if [ "$COMMENTS" != "true" ]
	then
		return 1
	fi

	local page="${1%.*}"
	local comment="$page.comment.txt"
	page="${page##*/}"

	if ! [ -f "$comment" ]
	then
		tput bold
		echo "comment not found: $comment" >&2
		tput sgr0
	elif [ -z "$(cat "$comment")" ]
	then
		tput bold
		echo "empty comment: $comment" >&2
		tput sgr0
	else
		generate_html_div "$1" begin comment-style
		OLD_IFS="$IFS"
		local line
		while read -r line
		do
			line="$(echo "$line" | sed -e 's/\([\.,!?;:]\)$/\1<br \/>/' -e 's/^$/<br \/>/')"
			echo -e "   $line" >> "./html-files/${index}.html"
		done < "$comment"
		IFS="$OLD_IFS"
		generate_html_div "$1" end
	fi
}

# requires absolute path to page
function generate_quick_access_section {
	local page="${1%.*}"
	page="${page##*/}"
	local next_index=
	local previous_index=

	generate_html_list "$1" begin pager #"float: left;"

	nearest_path "$1" up
	previous_index="$page_index"
	if [ -n "$previous_index" ]
	then
		generate_html_item "$1" "previous page" "${previous_index}.html" previous
	else
		generate_html_item "$1" "previous page" "#" "previous disabled"
		generate_html_item "$1" "top page" "index.html" middle
	fi

	nearest_path "$1" down
	next_index="$page_index"
	if [ -n "$next_index" ]
	then
		generate_html_item "$1" "next page" "${next_index}.html" next
	elif [ "$1" = "./README.md" ]
	then
		generate_html_item "$1" "next page" "1.0.html" next
	else
		generate_html_item "$1" "next page" "#" "next disabled"
		generate_html_item "$1" "top page" "index.html" middle
	fi

	if [ -n "$previous_index" ] && [ -n "$next_index" ]
	then
		generate_html_item "$1" "top page" "index.html" middle
	fi

	generate_html_list "$1" end pager
}

function generate_table_of_content {
	local hierarchy="${1%/*}"
	local entry=
	local indentation=
	local local_index=
	local title=

	while read -r entry
	do
		if [ -d "${hierarchy}/${entry}" ]
		then
			if [ -f "${hierarchy}/${entry%/}/.index" ]
			then
				generate_table_of_content "${hierarchy}/${entry%/}/.index"
			else
				tput bold
				echo "broken hierarchy in ${hierarchy}/${entry%/}/.index"
				tput sgr0
			fi
		elif ! [ -f "${hierarchy}/${entry}" ]
		then
			tput bold
			echo "missing entry in table of content: ${hierarchy}/${entry}"
			tput sgr0
			return 1
		elif ! [ -f "${hierarchy}/${entry%.*}.title.txt" ]
		then
			tput bold
			echo "missing entry title in table of content: ${hierarchy}/{$entry}"
			tput sgr0
			return 2
		else
			title="$(cat "${hierarchy}/${entry%.*}.title.txt")"
			index_page "${hierarchy}/${entry}"
			local_index="${page_index//[0-9]/}"
			local_index="${#local_index}"
			indentation="$(printf "%0.s " $(seq 1 "$local_index"))"
			title="${indentation}${page_index}. ${title}"
			generate_html_link "$1" "${page_index}.html" "$title"
			generate_html_break "$1"
		fi
	done < "${hierarchy}/.index"
}

function generate_index_page {
	local page="./html-files/index.html"
	index=index

	generate_html_section "$page" begin
	generate_html_head "$page" begin Practices
	generate_html_style "$1"
	generate_html_head "$page" end
	generate_html_body "$page" begin
	generate_html_header "$1" 2 "Table of Content"
	generate_html_div "$1" begin table-of-content
	generate_table_of_content "./.index"
	generate_html_div "$1" end
	generate_html_script "$1"
	generate_html_body "$page" end
	generate_html_section "$page" end
}

# functions to start the script working
###############################################################################

# requires path to page
function generate_page {
	index_page "$1"
	index="$page_index"
	generate_html_section "$1" begin
	generate_html_head "$1" begin
	generate_html_style "$1"
	generate_html_head "$1" end
	generate_html_body "$1" begin
	generate_html_div "$1" begin container
	generate_breadcrumb_section "$1"
	generate_header_section "$1"
	generate_comment_section "$1"
	generate_source_section $@
	generate_output_section $@
	generate_quick_access_section "$1"
	generate_html_div "$1" end container
	generate_html_script "$1"
	generate_html_body "$1" end
	generate_html_section "$1" end
	index=
}

# requires absolute path to page
function generate_chapter {
	index_page "$1/README.md"
	index="$page_index"
	generate_html_section "$1/README.md" begin
	generate_html_head "$1/README.md" begin
	generate_html_head "$1/README.md" end
	generate_html_body "$1/README.md" begin
	generate_html_style "$1"
	generate_breadcrumb_section "$1"
	generate_header_section "$1/README.md"
	generate_comment_section "$1/README.md"
	generate_quick_access_section "$1/README.md"
	generate_html_script "$1"
	generate_html_body "$1/README.md" end
	generate_html_section "$1/README.md" end
	index=
}

# requires relative path to list
function expand_list {
	local directory
	local members
	local group

	directory="${1%/*}"

	if ! [ -f "$1" ]
	then
		tput bold
		echo "unindexed directory: $directory/" >&2
		tput sgr0
		return 1
	fi

	local line
	while read -r line
	do
#		members="$(echo "$line" | wc -w)"
		members="${line//[^\ ]/}"

		if [ "${#members}" -gt 1 ]
		then
			for file in $line
			do
				if [ -f "$directory/$file" ]
				then
					group="$group $directory/$file"
				else
					tput bold
					echo "missing group member: $directory/$file" >&2
					tput sgr0
					continue 2
				fi
			done
			generate_page $group
		elif [ -f "$directory/$line" ]
		then
			generate_page "$directory/$line"
		elif [ -d "$directory/$line" ]
		then
			expand_list "$directory/$line/.index"
		else
			tput bold
			echo "missing entry: $directory/$line" >&2
			tput sgr0
		fi
		group=
	done < "$1"
}

# requires full path to first index file to recusrively build document
# must be called with trailing ./ in first argument
function generate_manuals {
	if [ -d ./html-files/ ]
	then
		rm -r ./html-files/
	fi

	mkdir ./html-files/

	if expand_list "$1"
	then
		generate_index_page

		# include bootstrap
		if [ -f "bootstrap.min.css" ] && [ -f "bootstrap.min.js" ]
		then
			cp bootstrap.min.* html-files/
		fi
	fi
}

# functions for specific options
###############################################################################

# requires absolute path to page
function generate_configuration {
	local page

	if [ -f "$1" ]
	then
		page="${1%.*}.config"
	elif [ -d "$1" ]
	then
		page="${1%/}/.config"
	else
		tput bold
		echo "invalid location to create config file"
		tput sgr0
		return 1
	fi

	cat << EOF > "$page"
## Program used to interpret or compile the practice file
COMPILER=
COMPILER_OPTIONS=

## Whether source should be compiled
## Set false for scripting languages
COMPILABLE=true

## Whether all sources in one line of .index file should appear in linkage
## usually other files are headers only and won't need to be linked to source
INCLUDES=false

## Whether linker explicitly specified
## This is only used for compilable sources
LINKER=
LINKER_OPTIONS=
LINKABLE=

## Whether source can be executed either as compiled source or interpretable
## Set to false for text files
EXECUTABLE=true

## Whether different sections should appear
## Source is always false for readme files
COMMENTS=true
SOURCE=true

## Following extensions will be generated when new practices are created
ADDITIONAL_EXTENSIONS="reference.txt comment.txt title.txt"

## This feature will be used later
TECHNICAL_LEVEL=

## Whether comments should be verified by .reference.txt files or not.
## This feature will be used later
REFERENCE_VALIDITY=true

## This feature will be used later
TERMINATE=false
TERMINATION_SIGNAL=SIGTERM
RUNTIME=3
EOF
}

# requires path to location where practice will be added
function add_practice {
	local location="${1%/*}"
	local practice_name="${1##*/}"

	if [ -z "$location" ]
	then
		tput bold
		echo "location not given" >&2
		tput sgr0
		return 1
	elif [ -z "$practice_name" ]
	then
		tput bold
		echo "practice name not given" >&2
		tput sgr0
		return 1
	elif ! [ -d "$location" ]
	then
		tput bold
		echo "location must be a directory: $location" >&2
		tput sgr0
		return 1
	elif [ $(grep -c "$practice_name" "${location}/.index") -gt 0 ]
	then
		tput bold
		echo "duplicate practice name: $practice_name" >&2
		tput sgr0
	fi

	# index practice in corresponding location
	echo "$practice_name" >> "${location}/.index"

	# create practice file itself
	touch "${location}/${practice_name}"

	practice_name="${practice_name%.*}"
	for extension in comment.txt title.txt reference.txt
	do
		touch "${location}/${practice_name}.${extension}"
	done
}

# requires path to location where chapter will be added
function add_chapter {
	local location="${1%/*}"
	local chapter_name="${1##*/}"

	if [ -z "$location" ]
	then
		tput bold
		echo "location not given" >&2
		tput sgr0
		return 1
	elif [ -z "$chapter_name" ]
	then
		tput bold
		echo "practice name not given" >&2
		tput sgr0
		return 1
	elif ! [ -d "$location" ]
	then
		tput bold
		echo "location must be a directory: $location" >&2
		tput sgr0
		return 1
	fi

	# if the holding directory itself does not have .index create one!
	if ! [ -f "${location}/.index" ] || [ "$(wc -l < "${location}/.index")" -eq 0 ]
	then
		# create additional extensions
		generate_configuration "${location}"

		echo "README.md" > "${location}/.index"
		echo -e "# Practice Repository\n" > "${location}/README.md"
		echo "This file is automatically created by Milestone Practice Manager" >> "${location}/README.md"
		echo "README.md" > "${location}/.index"
		for extension in comment.txt title.txt
		do
			touch "${location}/README.${extension}"
		done
		echo "EXECUTABLE=false" > "${location}/README.config"
		echo "SOURCE=false" >> "${location}/README.config"
	fi
	echo "$chapter_name" >> "${location}/.index"

	mkdir "${location}/${chapter_name}"
	echo -e "# $chapter_name\n" > "${location}/${chapter_name}/README.md"
	echo "This file is automatically created by Milestone Practice Manager" >> "${location}/${chapter_name}/README.md"
	echo "README.md" > "${location}/${chapter_name}/.index"

	for extension in comment.txt title.txt
	do
		touch "${location}/${chapter_name}/README.${extension}"
	done
	echo "EXECUTABLE=false" > "${location}/${chapter_name}/README.config"
	echo "SOURCE=false" >> "${location}/${chapter_name}/README.config"
}

# requires relative path to practice location
# requires page name as second argument
# optional page index as third argument
function join_practice {
	echo "not implemented yet"
}

function join_chapter {
	echo "not implemented yet"
}

# requires path to page
function remove_practice {
	local page="${1%.*}"
	local location="${1%/}"
	location="${location%/*}"

	if [ -f "$1" ]
	then
		rm "$page."*
		page="${page##*/}"
		sed -i "/${page}/d" "${location}/.index"
		echo "practice removed: ${1/$PWD\//}"
	else
		tput bold
		echo "practice page does not exist: ${1/$PWD\//}" >&2
		tput sgr0
		return 1
	fi
}

# requires path to directory
function remove_chapter {
	local location="${1%/}"
	location="${location%/*}"
	local chapter="${1%/}"
	chapter="${chapter##*/}"

	if [ -d "$1" ]
	then
		rm -r "$1"
		sed -i "/$chapter/d" "$location/.index"
		echo "chapter removed: ${1/$PWD\//}"
	else
		tput bold
		echo "chapter does not exist: ${1/$PWD\//}" >&2
		tput sgr0
		return 1
	fi
}

function rename_practice {
	echo "not implemented yet"
}

function rename_chapter {
	echo "not implemented yet"
}

function move_practice {
	echo "not implemented yet"
}

function move_chapter {
	local source="${1%/}"
	local destination="${2%/}"
	local index="$3"
	((index++)) # indexing starts from zero for readme files

	if ! [ -d "$source" ] && [ -d "${destination%/*}" ]
	then
		tput bold
		echo "source or destination does not exist!"
		tput sgr0
		return 1
	fi

	if [ -d "$destination" ]
	then
		if mv "$source" "$destination"
		then
			sed -i "/^${source##*/}$/d" "${source%/*}/.index"
			if [ -n "$index" ]
			then
				sed -i "${index}i ${source##*/}" "${destination}/.index"
			else
				echo "${source##*/}" >> "${destination}/.index"
			fi
		else
			tput bold
			echo "failed to move!"
			tput sgr0
		fi
	else
		if mv "$source" "$destination"
		then
			sed -i "/^${source##*/}$/d" "${source%/*}/.index"
			if [ -n "$index" ]
			then
				sed -i "${index}i ${destination##*/}" "${destination%/*}/.index"
			else
				echo "${destination##*/}" >> "${destination%/*}/.index"
			fi
		else
			tput bold
			echo "failed to move!"
			tput sgr0
		fi

	fi
}

function swap_practice {
	echo "not implemented yet"
}

function swap_chapter {
	local source="${1%/}"
	local destination="${2%/}"
	local source_index=
	local destination_index=
	
	if [ -d "$source" ] && [ -d "$destination" ]
	then
		source_index="$(grep -n "${source##*/}" "${source%/*}/.index")"
		source_index="${source_index%%:*}"
		((source_index--))
		destination_index="$(grep -n "${destination##*/}" "${destination%/*}/.index")"
		destination_index="${destination_index%%:*}"
		((destination_index--))

		if [ "${source%/*}" = "${destination%/*}" ]
		then
			sed -i "s/^${destination##*/}$/chapter_name_substitution/" "${destination%/*}/.index"
			sed -i "s/^${source##*/}$/${destination##*/}/" "${source%/*}/.index"
			sed -i "s/chapter_name_substitution/${source##*/}/" "${destination%/*}/.index"
		else
			move_chapter "$1" "./temporary_source_chapter"
			move_chapter "$2" "./temporary_destination_chapter"
			move_chapter "$PWD/temporary_source_chapter" "${destination%/*}" "$destination_index"
			move_chapter "$PWD/temporary_destination_chapter" "${source%/*}" "$source_index"
		fi
	else
		tput bold
		echo "source or destination does not exist"
		tput sgr0
	fi
}

function touch_sources {
	find -type f -name ".index" -exec sh -c '
		directory="{}"
		while read -r file
		do
			for entry in $file
			do
				filename="${directory%/*}/$entry"
				if [ -f "$filename" ]
				then
					touch "$filename"
				fi
			done
		done < {}' \;
}

# requires path to page or chapter
function remove_files {
	if [ -f "./${1#\.\/}" ]
	then
		remove_practice "./${1#\.\/}"
	else
		remove_chapter "./${1#\.\/}"
	fi
}

# requires path to source and destination
function move_files {
	echo "not implemented yet"
}

# requires relative path
function validate_files {
	local path="${1%/}"
	local extension="$(echo "$path" | sed -n 's/.*\.\([a-zA-Z]*\)$/\1/p')"

	# if does not have extension and exists and indexed: check all files within
	if [ -z "$extension" ] && [ -d "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 1 ]
	then
		echo "chapter exists and indexed: $path"
	# if does not have extension and exists but not indexed: check and join
	elif [ -z "$extension" ] && [ -d "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 0 ]
	then
		echo "chapter exists but not indexed: $path"
	# if does not have extension and does not exist: create chapter
	elif [ -z "$extension" ] && ! [ -d "$path" ]
	then
		add_chapter "$path"
	# if has extension and exists and indexed: check all files with it
	elif [ -n "$extension" ] && [ -f "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 1 ]
	then
		echo "page exists and indexed: $path"
	# if has extension and exists but is not indexed: check and join practice
	elif [ -n "$extension" ] && [ -f "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 0 ]
	then
		echo "page exists but not indexed: $path"
	# if has extension but does not exist, create practice page
	elif [ -n "$extension" ] && ! [ -f "$path" ]
	then
		add_practice "$path"
	# otherwise, unhandled error
	else
		return 1
	fi
}

function analyze_paramters {
	local source="${1#\.\/}"
	local destination="$2"

	if [ -z "$destination" ]
	then
		local hierarchy="."
		local entry=
		for entry in ${source//\//$'\n'}
		do
			hierarchy+="/$entry"
			if ! validate_files "${hierarchy/$PWD/}"
			then
				tput bold
				echo "path analysis failed on: $path" >&2
				tput sgr0
			fi
		done
	else
		destination="./${destination#\.\/}"
		if ! move_files "$source" "$destination"
		then
			tput bold
			echo "cannot move source: $source" >&2
			tput sgr0
		fi
	fi
}

# Analyze Options and Paramters
###############################################################################

#-a|--add-practice) add_practice "$PWD/$2"
#-A|--add-chapter) add_chapter "$PWD/$2"
#-j|--join-practice) join_practice "$PWD/$2"
#-J|--join-chapter) join_chapter "$PWD/$2"
#-r|--rename-practice) rename_practice "$PWD/$2" "$3"; shift 2 ;;
#-R|--rename-chapter) rename_chapter "$PWD/$2" "$3"; shift 2 ;;
#-m|--move-practice) move_practice "$PWD/$2" "$PWD/$3" "$4"; shift 3 ;;
#-M|--move-chapter) move_chapter "$PWD/$2" "$PWD/$3" "$4"; shift 3 ;;
#-s|--swap-practice) swap_practice "$PWD/$2" "$PWD/$3"; shift 2 ;;
#-S|--swap-chapter) swap_chapter "$PWD/$2" "$PWD/$3"; shift 2 ;;

if [ $# -eq 0 ]
then
	# At least one .index must exist at current directory
	# Everything starts here
	generate_manuals "./.index"
else
	case "$1" in
		-h|--help) usage ;;
		-r) remove_files "$2" ;;
		-f|--force-compile) touch_sources; generate_manuals "./.index" ;;
		*)
			if [ "${1:0:1}" = "-" ]
			then
				usage
			else
				analyze_paramters "$1" "$2"
			fi ;;
	esac
fi
