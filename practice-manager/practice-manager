#!/usr/bin/env bash

# required functions
###############################################################################

## description: outputs string with style and color
## usage: show [%style%/%color%] [string] ... [string]
## style list:
##     default normal bold italic strike-through blink
##     inline newline space align
## color list: black red green yellow blue magenta cyan white
## note: style and colors should be embraced by % sign
## note: only the last similar attribute in consecutive attributes is affected
## note: %inline% and %newline% attributes affect the whole line
## note: to align next lines, use %align% in string
function show {
	local output_style=sgr0
	local output_color
	local output_string
	local trailing_newline=true
	local word
	local margin
	local count_words=0

	if [ $# -eq 0 ]
	then
		echo
		return
	fi

	while [ $# -gt 0 ]
	do
		count_words="$(echo "$1" | wc -m)"
		for word in $1
		do
			case $word in
				# styles
				%bold%) output_style=${word//%/} ;;
				%normal%|default) output_style=sgr0; output_color= ;;
				%italic%) output_style=sgr0 ;;
				%strike-through%) output_style=sgr0 ;;
				%dim%) output_style=${word//%/} ;;
				%inline%) trailing_newline=false ;;
				%newline%) echo ;;
				%blink%) output_style=sgr0 ;;
				%space%) echo -n " " ;;
				%align%)
					if [ "$alignment_position" -gt 0 ]
					then
						printf "%.0s " $(seq 2 "$alignment_position")
					fi ;;
				# colors
				%black%) output_color=0 ;;
				%red%) output_color=1 ;;
				%green%) output_color=2 ;;
				%yellow%) output_color=3 ;;
				%blue%) output_color=4 ;;
				%magenta%) output_color=5 ;;
				%cyan%) output_color=6 ;;
				%white%) output_color=7 ;;
				# string
				*)
					# set output style first, then coloring
					tput $output_style
					if [ -n "$output_color" ]
					then
						tput setaf $output_color
					fi

					# store alignment position globally for next execution
					margin="${1%&align*}"
					margin="${#margin}"
					output_string=$word
					if [ "$margin" -lt "${#1}" ]
					then
						alignment_position=$((margin + 1))
						output_string="${word//&align/}"
					elif [ -z "$alignment_position" ]
					then
						alignment_position=0
					fi

					echo -ne "$output_string"
					if [ "$count_words" -gt 1 ] && [ "$word" != "&align" ]
					then
						echo -n " "
					fi
					((count_words--))
					;;
			esac
		done
		shift
	done
	
	# trailing newline is set unless inline attribute given
	if $trailing_newline;
	then
		echo
	fi
}

# terminates script executaion after call
function usage {
	echo "Practice Page Manager"
	echo
	echo "Usage: run under a practice directoy"
	echo
	echo "Options:"
	echo
	echo "  -a, --add_practice <path/to/directory> <page_name> [#position]"
	echo "  -A, --add_chapter <path/to/directory> <chapter_name> [#position]"
	echo
	echo "  -j, --join_practice <path/to/file> [#position]"
	echo "  -J, --join_chapter <path/to/directory> [#position]"
	echo
	echo "  -r, --remove_practice <path/to/file>"
	echo "  -d, --delete_practice <path/to/file>"
	echo "  -R, --remove_chapter <path/to/directory>"
	echo "  -D, --delete_chapter <path/to/directory>"
	echo
	echo "  -m, --move_practice <source> <destination> [#position]"
	echo "  -M, --move_chapter <source> <destination> [#position]"
	echo
	echo "  -f, --force_compile"
	exit 0
}

# html line generators
###############################################################################

# requires path to page
# requires begin/end as second parameter
function generate_html_section {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
<!DOCTYPE html>
<html lang="en_US">
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</html>
EOF
	fi
}

# requires path to page
# requires begin/end as second parameter
function generate_html_head {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local title="${3:-$page}"
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
 <head>
  <meta name="viewport" charset="UTF-8" content="width=device-width, initial-scale=1.0" />
  <title>${title}</title>
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
 </head>
EOF
	fi
}

# requires path to page
# requires header size
# requires title
function generate_html_header {
	local page="${1%.*}"
	page="${page##*/}"
	local size="${2:-1}"
	local title="${3:-header}"

	echo " <h${size}>$title</h${size}>" >> "./html-files/${index}.html"
}

# requires path to page
# optional style names [multiple names allowed]
function generate_style {
	local page="${1%.*}"
	page="${page##*/}"

	echo "  <style>" >> "./html-files/${index}.html"

	# default style
	cat << EOF >> "./html-files/${index}.html"
   hr {
     width:50%;
     margin-left:0;
     height:1px;
     border-width:0;
     color:gray;
     background-color:gray;
   }
EOF

	cat << EOF >> "./html-files/${index}.html"
   .quick-access {
    width: 70%; 
	padding-bottom: 50px;
   }

   .quick-access-row {
	text-align: center;
    float: left;
    position: relative;
    width: 26.67%; 
    margin-left: 0% ;
   }
EOF

	echo "  </style>" >> "./html-files/${index}.html"
}

# requires path to page
# requires begin/end as second parameter
function generate_html_body {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
 <body>
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
 </body>
EOF
	fi
}

# requires path to page
# optional css style name
function generate_html_code {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local css_style="$3"
	local code_tag

	if [ -n "$css_style" ]
	then
		code_tag="<code class=\"${css_style}\">"
	else
		code_tag="<code>"
	fi

	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
  <pre>
   ${code_tag}
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
   </code>
  </pre>
EOF
	fi
}

# requires path to page
# optional begin/end
# optional css style name
function generate_html_div {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local css_style="$3"
	local div_tag

	if [ -n "$css_style" ]
	then
		div_tag="<div class=\"${css_style}\">"
	else
		div_tag="<div>"
	fi

	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
  ${div_tag}
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
  </div>
EOF
	fi
}

# requires path to page
function generate_html_break {
	echo "    <br />" >> "./html-files/${index}.html"
}

# requires path to page
# requires link
# requires title
function generate_html_link {
	local page="${1%.*}"
	page="${page##*/}"
	local link="${2:-#}"
	local title="${3:-link}"

	echo "    <a href=\"$link\">$title</a>" >> "./html-files/${index}.html"
}

# requires path to page
# requies text
# optional command
function generate_html_text {
	local page="$1"
	local text="$2"
	local style="$3"
	local tag=

	if [ -n "$style" ]
	then
		tag="<p class=\"${style}\">"
	else
		tag="<p>"
	fi

	echo "   ${tag}${text}</p>" >> "./html-files/${index}.html"
}

# required functions for managing practice pages
###############################################################################

# requires absolute path to source to configure corresponding variables
function update_configuration {
	local directory
	local config

	for level in ${1//\//$'\n'}
	do
		if [ -d "$directory$level" ]
		then
			directory="$directory$level/"
		elif [ -f "$directory$level" ]
		then
			directory="$directory${level%.*}"
		fi

		config="$directory.config"

		if [ -f "$config" ]
		then
			source "$config"
		fi
	done
}

# requires path to page
# requires compile/link/run option
# requires command
function generate_execution_mode {
	local page="${1}"
	local mode="${2:-compile}"
	local command="${3}"

	if [ -z "$command" ]
	then
		tput bold
		echo "execution command not specified: $page"
		tput sgr0
		return 1
	fi

	generate_html_header "$1" 4 "${mode}"
	generate_html_text "$1" "$command" command-style
}

# requires absolute path to source
# option headers and required files
function compile_source {
	update_configuration "$1"

	if [ "$EXECUTABLE" != "true" ]
	then
		return 2
	fi

	generate_html_header "$1" 2 "Execution"

	local binary="${1%.*}.bin"
	local object="${1%.*}.o"
	local headers="$@"
	headers="${headers/$1 }"
	local includes=
	local output="${1%.*}.output.txt"
	local execution_command
	local output_change_time
	local source_change_time

	if [ "$COMPILABLE" = "true" ] && [ -z "$COMPILER" ]
	then
		echo "$COMPILABLE $COMPILER"
		tput bold
		echo "compiler not specified for: $1" >&2
		tput sgr0
		return 1
	fi

	if [ "$INCLUDES" != "true" ]
	then
		headers=
	fi

	source_change_time=$(stat -c "%Y" "$1")

	if [ -f "$output" ]
	then
		output_change_time=$(stat -c "%Y" "$output")
	else
		output_change_time=0
	fi

	if ! [ -f "$output" ] || [ "$source_change_time" -ge "$output_change_time" ]
	then
		if [ "$COMPILABLE" = "true" ]
		then
			execution_command="$COMPILER $COMPILER_OPTIONS $object $1"
			if ! $execution_command
			then
				tput bold
				echo "compilation error: $1" >&2
				tput sgr0
				return 1
			fi
			generate_execution_mode "$1" compile "$execution_command"
		else
			if [ -f "$binary" ]
			then
				unlink "$binary"
			fi
			ln -s "$PWD/$1" "$binary"
		fi
	else
		if [ "$COMPILABLE" = "true" ]
		then
			execution_command="$COMPILER $COMPILER_OPTIONS ${object##*/} ${1##*/}"
			generate_execution_mode "$1" compile "$execution_command"
		fi
	fi

	execution_command="$LINKER $LINKER_OPTIONS $binary $object $headers"

	if ! [ -f "$output" ] || [ "$source_change_time" -ge "$output_change_time" ]
	then
		if [ "$COMPILABLE" = "true" ] && [ -n "$LINKER" ]
		then
			if ! $execution_command
			then
				tput bold
				echo "linkage error for: $1" >&2
				tput sgr0
				return 1
			fi
		elif [ "$COMPILABLE" = "true" ] && [ -z "$LINKER" ]
		then
			tput bold
			echo "linker not specified for: $1" >&2
			tput sgr0
			return 1
		fi
	fi

	if [ "$COMPILABLE" = "true" ]
	then
		binary="${binary##*/}"
		object="${object##*/}"
		for header in $headers
		do
			includes+="$header "
		done

		execution_command="$LINKER $LINKER_OPTIONS $binary $object $includes"
		generate_execution_mode "$1" link "$execution_command"
	fi
}

# requires path to page
# optional floor to start indexing directories
# sets page_index and page_hierarchy variables
function index_page {
	local floor="${2:-1}"

	local depth=1
	local entry=
	local hierarchy=
	local index=
	page_index=
	page_hierarchy=

	for entry in ${1//\//$'\n'}
	do
		hierarchy="${hierarchy:-$entry}"

		if [ "$depth" -gt "$floor" ]
		then
			match="$(grep -n "$entry" "${hierarchy}/.index")"
			match="${match%%:*}"
			match="${match%% *}"
			((match--)) # shift index down because of readme indexes
			index+="${match}."
		fi

		((depth++))
		hierarchy="${hierarchy}/${entry}"
	done
	page_index="${index%.}"
	page_hierarchy="$hierarchy"
}

# requires path to page
# optional up/down for direction of growth
# sets deepest_page variable
function deepest_path {
	local hierarchy="${1%/}"
	local direction="${2:-up}"

	local entry=
	local tool=
	deepest_page=

	if [ "$direction" = "up" ]
	then
		tool="head"
	elif [ "$direction" = "down" ]
	then
		tool="tail"
	else
		return 1
	fi

	while true
	do
		if [ -d "$hierarchy" ] && [ -f "${hierarchy}/.index" ]
		then
			entry="$("$tool" -n1 "${hierarchy}/.index")"
			entry="${entry%% *}"
			if [ -n "$entry" ]
			then
				hierarchy="${hierarchy}/${entry}"
			else
				break
			fi
		else
			break
		fi
	done
	deepest_page="$hierarchy"
}

# requires path to page
# optional up/down for direction of growth
# sets page_index and page_hierarchy variables
# note: empty variables means there is no neighbor
function nearest_path {
	local hierarchy="${1%/}"
	local page="${hierarchy##*/}"
	hierarchy="${hierarchy%/*}"
	local direction="${2:-up}"
	local match=
	local option=

	if [ "$direction" = "up" ]
	then
		option="-B1"
	elif [ "$direction" = "down" ]
	then
		option="-A1"
	else
		return 1
	fi

	while [ "$hierarchy" != "." ]
	do
		match="$(grep "$option" "$page" "${hierarchy}/.index")"

		if [ "$direction" = "up" ]
		then
			match="${match%$'\n'*}"
		else
			match="${match#*$'\n'}"
		fi
		match="${match%% *}"

		if [ "$match" = "$page" ]
		then
			page="${hierarchy##*/}"
			hierarchy="${hierarchy%/*}"
		else
			if [ "$direction" = "up" ]
			then
				direction="down"
			else
				direction="up"
			fi

			if [ -d "${hierarchy}/${match}" ]
			then
				deepest_path "${hierarchy}/${match}" "$direction"
				page="$deepest_page"
			else
				page="${hierarchy}/${match}"
			fi

			index_page "$page"
			break
		fi
	done

	if [ "$hierarchy" = "." ]
	then
		page_index=
		page_hierarchy=
	fi
}

# functions to generate html pages
###############################################################################

function generate_index_section {
	local tag="<h1>"

	echo -n "  ${tag}${index}. " >> "./html-files/${index}.html"
}

# requires path to page
function generate_header_section {
	local page="${1%.*}"
	local header="$page.title.txt"
	page="${page##*/}"
	local title
	local tag_end

	if ! [ -f "$header" ]
	then
		tput bold
		echo "header not found: $header" >&2
		tput sgr0
	elif [ -z "$(cat "$header")" ]
	then
		tput bold
		echo "empty header: $header" >&2
		echo "$tag_end" >> "./html-files/${index}.html"
		tput sgr0
	else
		title="$(cat "$header")"
		tag_end="</h1>"
		echo "${title}${tag_end}" >> "./html-files/${index}.html"
	fi
}

# requires path to page
function generate_page_name {
	local tag="<cite>"
	local tag_end="</cite>"

	echo "  ${tag}${1##*/}${tag_end}" >> "./html-files/${index}.html"
	echo "  <hr />" >> "./html-files/${index}.html"
}

# requires path to page
function generate_source_section {
	update_configuration "$1"

	if [ "$SOURCE" != "true" ]
	then
		return 1
	fi

	generate_html_header "$1" 2 "Source"
	while [ $# -gt 0 ]
	do
		generate_page_name "${1}"
		generate_html_code "$1" begin
		OLD_IFS="$IFS"
		IFS=
		local line
		while read -r line
		do
			line="${line//&/&amp;}"
			line="${line//\"/&quot;}"
			line="${line//\'/&apos;}"
			line="${line//</&lt;}"
			line="${line//>/&gt;}"
			echo "    $line" >> "./html-files/${index}.html"
		done < "$1"
		IFS="$OLD_IFS"
		generate_html_code "$1" end
		shift
	done
}

# requires absolute path to page
function generate_output_section {
	local page="${1%.*}"
	local binary="$page.bin"
	local output="$page.output.txt"
	local input="$page.input.txt"
	page="${page##*/}"

	if ! compile_source $@
	then
		return 1
	fi

	if ! [ -f "$binary" ]
	then
		tput bold
		echo "binary file not generated: $binary" >&2
		tput sgr0
		return 1
	fi

	if [ "$COMPILABLE" = "true" ]
	then
		if [ -f "$input" ]
		then
			"$binary" < "$input" > "$output"
		else
			"$binary" > "$output"
		fi
		generate_execution_mode "$1" run "./${binary##*/}"
	else
		if [ -f "$input" ]
		then
			"$COMPILER" "$binary" < "$input" > "$output"
		else
			"$COMPILER" "$binary" > "$output"
		fi
		generate_execution_mode "$1" run "$COMPILER ${1##*/}"
	fi
	echo >> "$output"

	local line
	if [ -f "$input" ]
	then
		echo "  <h2>Input</h2>" >> "./html-files/${index}.html"

		generate_html_div "$1" begin input-style
		while read -r line
		do
			echo "   $line" >> "./html-files/${index}.html"
		done < "$input"
		generate_html_div "$1" end
	fi

	echo "  <h2>Output</h2>" >> "./html-files/${index}.html"

	generate_html_div "$1" begin output-style
	if ! [ -f "$output" ]
	then
		tput bold
		echo "output file not found: $output" >&2
		tput sgr0
	else
		while read -r line
		do
			echo "   $line" >> "./html-files/${index}.html"
		done < "$output"
	fi
	generate_html_div "$1" end
}

# requires absolute path to page
function generate_comment_section {
	update_configuration "$1"

	if [ "$COMMENTS" != "true" ]
	then
		return 1
	fi

	local page="${1%.*}"
	local comment="$page.comment.txt"
	page="${page##*/}"

	if ! [ -f "$comment" ]
	then
		tput bold
		echo "comment not found: $comment" >&2
		tput sgr0
	elif [ -z "$(cat "$comment")" ]
	then
		tput bold
		echo "empty comment: $comment" >&2
		tput sgr0
	else
		generate_html_div "$1" begin comment-style
		OLD_IFS="$IFS"
		local line
		while read -r line
		do
			echo -e "   ${line/.\n/.EOL<br />}" >> "./html-files/${index}.html"
		done < "$comment"
		IFS="$OLD_IFS"
		generate_html_div "$1" end
	fi
}

# requires absolute path to page
function generate_quick_access_section {
	local page="${1%.*}"
	page="${page##*/}"
	local next_index=
	local previous_index=

	generate_html_header "$1" 2 "Quick Access"
	generate_html_div "$1" begin quick-access

	nearest_path "$1" up
	previous_index="$page_index"
	if [ -n "$previous_index" ]
	then
		generate_html_div "$1" begin quick-access-row
		generate_html_link "$1" "${previous_index}.html" "previous page"
		generate_html_div "$1" end quick-access-row
	elif [ "$1" = "./README.md" ]
	then
		generate_html_div "$1" begin quick-access-row
		generate_html_link "$1" "index.html" "top page"
		generate_html_div "$1" end quick-access-row
	else
		generate_html_div "$1" begin quick-access-row
		generate_html_link "$1" "0.html" "previous page"
		generate_html_div "$1" end quick-access-row
	fi

	nearest_path "$1" down
	next_index="$page_index"
	if [ -n "$next_index" ]
	then
		generate_html_div "$1" begin quick-access-row
		generate_html_link "$1" "${next_index}.html" "next page"
		generate_html_div "$1" end quick-access-row
	elif [ "$1" = "./README.md" ]
	then
		generate_html_div "$1" begin quick-access-row
		generate_html_link "$1" "1.0.html" "next page"
		generate_html_div "$1" end quick-access-row
	else
		generate_html_div "$1" begin quick-access-row
		generate_html_link "$1" "index.html" "top page"
		generate_html_div "$1" end quick-access-row
	fi

	if [ -n "$previous_index" ] && [ -n "$next_index" ]
	then
		generate_html_div "$1" begin quick-access-row
		generate_html_link "$1" "index.html" "top page"
		generate_html_div "$1" end quick-access-row
	fi

	generate_html_div "$1" end
}

function generate_table_of_content {
	local hierarchy="${1%/*}"
	local entry=
	local indentation=
	local local_index=
	local title=

	while read -r entry
	do
		if [ -d "${hierarchy}/${entry}" ]
		then
			if [ -f "${hierarchy}/${entry%/}/.index" ]
			then
				generate_table_of_content "${hierarchy}/${entry%/}/.index"
			else
				tput bold
				echo "broken hierarchy in ${hierarchy}/${entry%/}/.index"
				tput sgr0
			fi
		elif ! [ -f "${hierarchy}/${entry}" ]
		then
			tput bold
			echo "missing entry in table of content: ${hierarchy}/${entry}"
			tput sgr0
			return 1
		elif ! [ -f "${hierarchy}/${entry%.*}.title.txt" ]
		then
			tput bold
			echo "missing entry title in table of content: ${hierarchy}/{$entry}"
			tput sgr0
			return 2
		else
			title="$(cat "${hierarchy}/${entry%.*}.title.txt")"
			index_page "${hierarchy}/${entry}"
			local_index="${page_index//[0-9]/}"
			local_index="${#local_index}"
			indentation="$(printf "%0.s " $(seq 1 "$local_index"))"
			title="${indentation}${page_index}. ${title}"
			generate_html_link "$1" "${page_index}.html" "$title"
			generate_html_break "$1"
		fi
	done < "${hierarchy}/.index"
}

function generate_index_page {
	local page="./html-files/index.html"
	index=index

	generate_html_section "$page" begin
	generate_html_head "$page" begin Practices
	generate_html_head "$page" end
	generate_html_body "$page" begin
	generate_html_header "$1" 2 "Table of Content"
	generate_html_div "$1" begin table-of-content
	generate_table_of_content "./.index"
	generate_html_div "$1" end
	generate_html_body "$page" end
	generate_html_section "$page" end
}

# functions to start the script working
###############################################################################

# requires path to page
function generate_page {
	index_page "$1"
	index="$page_index"
	generate_html_section "$1" begin
	generate_html_head "$1" begin
	generate_style "$1"
	generate_html_head "$1" end
	generate_html_body "$1" begin
	generate_index_section "$1"
	generate_header_section "$1"
	generate_comment_section "$1"
	generate_source_section $@
	generate_output_section $@
	generate_quick_access_section "$1"
	generate_html_body "$1" end
	generate_html_section "$1" end
	index=
}

# requires absolute path to page
function generate_chapter {
	index_page "$1/README.md"
	index="$page_index"
	generate_html_section "$1/README.md" begin
	generate_html_head "$1/README.md" begin
	generate_style "$1/README.md"
	generate_html_head "$1/README.md" end
	generate_html_body "$1/README.md" begin
	generate_index_section "$1/README.md"
	generate_header_section "$1/README.md"
	generate_comment_section "$1/README.md"
	generate_quick_access_section "$1/README.md"
	generate_html_body "$1/README.md" end
	generate_html_section "$1/README.md" end
	index=
}

# requires relative path to list
function expand_list {
	local directory
	local members
	local group

	directory="${1%/*}"

	if ! [ -f "$1" ]
	then
		tput bold
		echo "unindexed directory: $directory/" >&2
		tput sgr0
		return 1
	fi

	local line
	while read -r line
	do
		members="$(echo "$line" | wc -w)"

		if [ "$members" -gt 1 ]
		then
			for file in $line
			do
				if [ -f "$directory/$file" ]
				then
					group="$group $directory/$file"
				else
					tput bold
					echo "missing group member: $directory/$file" >&2
					tput sgr0
					continue 2
				fi
			done
			generate_page $group
		elif [ -f "$directory/$line" ]
		then
			generate_page "$directory/$line"
		elif [ -d "$directory/$line" ]
		then
			expand_list "$directory/$line/.index"
		else
			tput bold
			echo "missing entry: $directory/$line" >&2
			tput sgr0
		fi
		group=
	done < "$1"
}

# requires full path to first index file to recusrively build document
# must be called with trailing ./ in first argument
function generate_manuals {
	if [ -d ./html-files/ ]
	then
		rm -r ./html-files/
	fi

	mkdir ./html-files/

	generate_index_page

	expand_list "$1"
}

# functions for specific options
###############################################################################

# requires absolute path to page
function generate_configuration {
	local page

	if [ -f "$1" ]
	then
		page="${1%.*}.config"
	elif [ -d "$1" ]
	then
		page="${1%/}/.config"
	fi

	cat << EOF > "$page"
COMPILER=
COMPILER_OPTIONS=
COMPILABLE=true
LINKER=
LINKER_OPTIONS=
EXECUTABLE=true
INCLUDES=false
COMMENTS=true
ADDITIONAL_EXTENSIONS="reference.txt comment.txt title.txt"
# levels: amateur, intermediate, expert
TECHNICAL_LEVEL=
EOF
}

# requires path to location where practice will be added
# requires practice name as second parameter
# optional position as third paramter
function add_practice {
	local location="${1%/}"
	local practice_name="$2"
	local position="$3"

	if [ -z "$location" ]
	then
		tput bold
		echo "location not given" >&2
		tput sgr0
		return 1
	elif [ -z "$practice_name" ]
	then
		tput bold
		echo "practice name not given" >&2
		tput sgr0
		return 1
	elif ! [ -d "$location" ]
	then
		tput bold
		echo "location must be a directory" >&2
		tput sgr0
		return 1
	elif [ $(grep -c "$practice_name" "${location}/.index") -gt 0 ]
	then
		tput bold
		echo "duplicate practice name: $practice_name" >&2
		tput sgr0
	fi

	# index practice in corresponding location
	if [ -n "$position" ] && [ -f "${location}/.index" ]
	then
		# only readme files are in position 1, shift all indexed up
		((position++))
		sed -i "${position}i ${practice_name}" "${location}/.index"
	else
		echo "$practice_name" >> "${location}/.index"
	fi

	# create practice file itself
	touch "${location}/${practice_name}"

	# create additional extensions
	generate_configuration "${location}/${practice_name}"

	update_configuration "${location}/${practice_name}"

	practice_name="${practice_name%.*}"
	for extension in $ADDITIONAL_EXTENSIONS
	do
		if [ "$extension" = "comment.txt" ] && [ "$COMMENTS" != "true" ]
		then
			continue
		fi

		touch "${location}/${practice_name}.${extension}"
	done

	echo "files created:"
	find "${location//$PWD/.}" -type f -name "${practice_name}*" | nl
}

# requires path to location where chapter will be added
# requires chapter name as second parameter
# optional position as third paramter
function add_chapter {
	local location="${1%/}"
	local chapter_name="$2"
	local position="$3"

	if [ -z "$location" ]
	then
		tput bold
		echo "location not given" >&2
		tput sgr0
		return 1
	elif [ -z "$chapter_name" ]
	then
		tput bold
		echo "chapter name not given" >&2
		tput sgr0
		return 1
	elif ! [ -d "$location" ]
	then
		tput bold
		echo "location must be a directory" >&2
		tput sgr0
		return 1
	fi

	# index chapter in corresponding location
	if [ -n "$position" ] && [ -f "${location}/.index" ]
	then
		# only readme files are in index 0, shift all indexes up
		((position++))
		sed -i "${position}i ${chapter_name}" "${location}/.index"
	else
		if ! [ -f "${location}/.index" ] || [ "$(wc -l < "${location}/.index")" -eq 0 ]
		then
			echo "README.md" > "${location}/.index"
		fi
		echo "$chapter_name" >> "${location}/.index"
	fi

	mkdir "${location}/${chapter_name}"
	echo "# $chapter_name" > "${location}/${chapter_name}/README.md"
	echo "This file is automatically created by Milestone Practice Manager" >>\
	   	"${location}/${chapter_name}/README.md"
	echo "README.md" > "${location}/${chapter_name}/.index"

	# create additional extensions
	generate_configuration "${location}/${chapter_name}"

	update_configuration "${location}/${chapter_name}/README.md"

	for extension in $ADDITIONAL_EXTENSIONS
	do
		touch "${location}/${chapter_name}/README.${extension}"
	done
	echo "EXECUTABLE=false" > "${location}/${chapter_name}/README.config"
	echo "SOURCE=false" > "${location}/${chapter_name}/README.config"

	echo "files created:"
	find "${location//$PWD/.}/${chapter_name}/" -type f | nl
}

# requires relative path to practice location
# requires page name as second argument
# optional page index as third argument
function join_practice {
	local location="${1%/}"
}

function join_chapter {
	local location="${1%/}"
}

# requires path to page
function remove_practice {
	local page="${1%.*}"
	local location="${1%/}"
	location="${location%/*}"

	if [ -f "$1" ]
	then
		rm "$page."*
		page="${page##*/}"
		sed -i "/${page}/d" "${location}/.index"
		echo "practice removed: ${1/$PWD\//}"
	else
		tput bold
		echo "practice page does not exist: ${1/$PWD\//}" >&2
		tput sgr0
		return 1
	fi
}

# requires path to directory
function remove_chapter {
	local location="${1%/}"
	location="${location%/*}"
	local chapter="${1%/}"
	chapter="${chapter##*/}"

	if [ -d "$1" ]
	then
		rm -r "$1"
		sed -i "/$chapter/d" "$location/.index"
		echo "chapter removed: ${1/$PWD\//}"
	else
		tput bold
		echo "chapter does not exist: ${1/$PWD\//}" >&2
		tput sgr0
		return 1
	fi
}

function move_practice {
	local location="${1%/}"
}

function move_chapter {
	local location="${1%/}"
}

function touch_sources {
	find -type f -name ".index" -exec sh -c '
		directory="{}"
		while read -r file
		do
			for entry in $file
			do
				filename="${directory%/*}/$entry"
				if [ -f "$filename" ]
				then
					touch "$filename"
				fi
			done
		done < {}' \;
}

# Parameter Parser
###############################################################################

if [ $# -eq 0 ]
then
	generate_manuals "./.index"
else
	while [ $# -gt 0 ]
	do
		case "$1" in
			-h|--help) usage ;;
			-a|--add-practice) add_practice "$PWD/$2" "$3" "$4"; shift 3 ;;
			-A|--add-chapter) add_chapter "$PWD/$2" "$3" "$4"; shift 3 ;;
			-j|--join-practice) join_practice "$PWD/$2" "$3"; shift 2 ;;
			-J|--join-chapter) join_chapter "$PWD/$2" "$3"; shift 2 ;;
			-r|-d|--remove-practice) remove_practice "$PWD/$2"; shift 1 ;;
			-R|-D|--remoe-chapter) remove_chapter "$PWD/$2"; shift 1 ;;
			-m|--move-practice) move_practice "$PWD/$2" "$3" "$4"; shift 3 ;;
			-M|--move-chapter) move_chapter "$PWD/$2" "$3" "$4"; shift 3 ;;
			-f|--force-compile) touch_sources; generate_manuals "./.index" ;;
			*) usage ;;
		esac
		shift
	done
fi
