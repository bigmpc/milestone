#!/usr/bin/env bash

main_configuration=\
"## Language name for syntax highlighting
## Only specify names supported by prism.js
## e.g. c cpp java python bash
#LANGUAGE=

## Whether source can be executed either as compiled source or interpretable
## Set to false for text files
#EXECUTABLE=true

## Program used to interpret or compile the practice file
#COMPILER=
#COMPILER_OPTIONS=

## Order of statements in compilation command
## Available statements: compiler, options, object, source, headers
#COMPILATION_SCHEME=\"compiler options object source\"

## Whether source should be compiled
## Set false for scripting languages
#COMPILABLE=true

## Whether all sources in one line of .index file should appear in linkage
## usually other files are headers only and won't need to be linked to source
#INCLUDES=false

## What is the extension of the object which compiler throws?
## Default is set to .o
#OUTPUT_OBJECT=

## Whether linker explicitly specified
## This is only used for compilable sources
#LINKER=
#LINKER_OPTIONS=

## Order of statements in linkage command
## Available statements: linker, options, binary, object, headers, source,
##   location, page
#LINKAGE_SCHEME=\"linker options binary object headers\"

## Whether object should be linked after compilation too
## Defaut is set to true
## Set false for scripts
#LINKABLE=true

## Wether generated output can run as an executable
#RUNNABLE=true
#RUNNING_OPTIONS=

## Order of statements in running command
## Available statements: compiler, linker, options, binary, object, headers,
##   source, location, page
#RUNNING_SCHEME=\"binary options\"

## Whether program should be run in the background
## Suitable for servers and services which need to wait for clients to compile
## and respond
## Rationally, servers should be compiled and executed first, then clients
#RUN_IN_BACKGROUND=false

## Terminate program in RUNTIME seconds after exection
## Suitable for servers which will not exit after execution
#TERMINATE=false
#TERMINATION_SIGNAL=SIGTERM
#RUNTIME=3

## Whether different sections should appear
## Source is always false for readme files in order to prevent text duplication
## Suitable for text sources which cannot be compiled
#TITLE=true
#COMMENTS=true
#SOURCE=true
#EXECUTION=true
#OUTPUT=true
#INPUT=true
#REFERENCE=true

## Whether comments should be verified by .reference.txt files or not.
## This feature will be used in the future
#REFERENCE_VALIDITY=false

## Specify the hardness of this chapter
## This feature will be used in Milestone technical courses and tutorials
#TECHNICAL_LEVEL=

## DO NOT EDIT!
#VALIDATION_ID=0"

# terminates script executaion after call
function usage {
	echo "Practice Page Manager"
	echo
	tput bold
	echo "Options:"
	tput sgr0
	echo
	echo "  -r <path/to/file>     Remove page or chapter"
	echo "  -o <path/to/file>     Reorder index of page or chapter"
	echo "  -f                    Force compile, regenerates all output files"
	echo
	tput bold
	echo "Usage:"
	tput sgr0
	echo
	tput setaf 7
	echo "  $ practice-manager"
	tput sgr0
	echo "                        Reads files and generates html-files"
	echo
	tput setaf 7
	echo "  $ practice-manager <source> <destination>"
	tput sgr0
	echo "                        Moves and/or renames page and/or chapter"
	echo
	tput setaf 7
	echo "  $ practice-manager <path>"
	tput sgr0
	echo "                        Create chapter or page, or just peek inside"
}

# html line generators
###############################################################################

# requires path to page
# requires begin/end as second parameter
function generate_html_section {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
<!DOCTYPE html>
<html lang="en">
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</html>
EOF
	fi
}

# requires path to page
# requires begin/end as second parameter
function generate_html_head {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local title=

	if [ -f "${1%.*}.title.txt" ]
	then
		title="$(cat "${1%.*}.title.txt")"
	fi
	
	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<!-- bootstrap -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
<!-- prims plugin styles -->
<Link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autolinker/prism-autolinker.min.css" rel="stylesheet">
<Link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/command-line/prism-command-line.min.css" rel="stylesheet">
<Link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
<Link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet">
<!-- ajax -->
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism-tomorrow.min.css'>

<title>${title:-"Milestone Practices"}</title>
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</head>
EOF
	fi
}

# requires path to page
# requires header size
# requires title
function generate_html_header {
	local page="${1%.*}"
	page="${page##*/}"
	local size="${2:-1}"
	local title="${3:-header}"

	echo "<h${size}>$title</h${size}>" >> "./html-files/${index}.html"
}

# requires path to page
# requires header size
# requires title
# requires link
function generate_html_header_with_link {
	local page="${1%.*}"
	page="${page##*/}"
	local size="${2:-1}"
	local title="${3:-header}"
	local link="${4:-#}"

	echo "<h${size}><a href="$link">$title</a></h${size}>" >> "./html-files/${index}.html"
}

# requires path to page
# optional style names [multiple names allowed]
function generate_html_style {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local style="$3"

	if [ -z "$style" ]
	then
		if [ "$side" = "begin" ]
		then
			echo "<style>" >> "./html-files/${index}.html"

			cat << 'EOF' >> "./html-files/${index}.html"
a,
a:hover,
a:focus {
	text-decoration: none;
}

.pager .top {
	float: center;
}

.dark-mode {
	background-color: black;
	color: #aaaaaa;
}

.dark-mode .page-link {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .page-link .disabled li > a {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .pager li > a,
.dark-mode .pager li > span {
	color: #bdc0c4;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .pager li > a:hover,
.dark-mode .pager li > a:focus,
.dark-mode .pager li > span:hover {
	color: #6c757d;
}

.dark-mode .pager .disabled a,
.dark-mode .pager .disabled a:hover,
.dark-mode .pager .disabled a:focus {
	color: #6c757d;
	background-color: #212529;
	border: 1px solid #616161;
}

.dark-mode .breadcrumb {
	background-color: #212529;
}

.dark-mode .breadcrumb a {
	color: #bdc0c4;
}

.dark-mode .breadcrumb a:hover,
.dark-mode .breadcrumb a:focus {
	text-decoration: none;
	color: #777777;
}

.breadcrumb a,
.breadcrumb a:hover,
.breadcrumb a:focus {
	text-decoration: none;
}

/* prism overrides */
div.code-toolbar>.toolbar a,
div.code-toolbar>.toolbar button,
div.code-toolbar>.toolbar span {
	margin-left: 0.7rem;
}

pre {
	margin-bottom: 1.3rem !important;
}

.breadcrumb-item+.breadcrumb-item::before {
	content: '> ';
}

EOF
		elif [ "$side" = "end" ]
		then
			echo "</style>" >> "./html-files/${index}.html"
		fi
	else
		case "$style" in
			nested-list)
				cat << EOF >> "./html-files/${index}.html"
.just-padding {
  padding: 15px;
}

.list-group.list-group-root {
  padding: 0;
  overflow: hidden;
}

.list-group.list-group-root .list-group {
  margin-bottom: 0;
}

.list-group.list-group-root .list-group-item {
  border-radius: 0;
  border-width: 1px 0 0 0;
}

.list-group.list-group-root > .list-group-item:first-child {
  border-top-width: 0;
}

.list-group.list-group-root > .list-group > .list-group-item {
  padding-left: 30px;
}

.list-group.list-group-root > .list-group > .list-group > .list-group-item {
  padding-left: 45px;
}

.list-group-item .glyphicon {
  margin-right: 5px;
}
EOF
				;;
			*)
				;;
		esac
	fi
}

# requires path to page
# optional style names [multiple names allowed]
function generate_html_script {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local script="$3"

	if [ -z "$script" ]
	then
		if [ "$side" = "begin" ]
		then
			echo "<script>" >> "./html-files/${index}.html"

			cat << 'EOF' >> "./html-files/${index}.html"
function darkmode(manual = false) {
	const hours = new Date().getHours()
	const isDayTime = hours > 6 && hours < 20
	var bodystyle = document.body;
    if (!isDayTime || manual) {
   		bodystyle.classList.add("dark-mode");
    } else {
   		bodystyle.classList.remove("dark-mode");
	}
}
darkmode();
EOF
		elif [ "$side" = "end" ]
		then
			echo "</script>" >> "./html-files/${index}.html"
		fi
	else
		case "$script" in
			nested-list)
				cat << 'EOF' >> "./html-files/${index}.html"
$(function() {
  $('.list-group-item').on('click', function() {
    $('.glyphicon', this)
      .toggleClass('glyphicon-chevron-right')
      .toggleClass('glyphicon-chevron-down');
  });
});
EOF
				;;
			*)
				;;
		esac
	fi
}

# requires path to page
# requires begin/end as second parameter
function generate_html_body {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	
	if [ "$side" = "begin" ]
	then
#<body class="p-3">
		cat << EOF >> "./html-files/${index}.html"
<body class="container">
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<!-- bootstrap -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
<!-- prism js -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/prism.min.js'></script>
<!-- prism languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-c.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-clike.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-asm6502.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-cpp.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-java.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-bash.min.js"></script>
<!-- prism plugins -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/toolbar/prism-toolbar.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/autolinker/prism-autolinker.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/command-line/prism-command-line.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/remove-initial-line-feed/prism-remove-initial-line-feed.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/show-language/prism-show-language.min.js"></script>
</body>
EOF
	fi
}

# requires path to page
# optional begin/end
# optional pre class
# optional code class
# optional attributes
function generate_html_code {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local pre_class="$3"
	local code_class="$4"
	local code_tag

	if [ -n "$code_class" ]
	then
		code_tag="<code class=\"${code_class}\">"
	else
		code_tag="<code>"
	fi

	if [ "$side" = "begin" ]
	then
		shift 4
		cat << EOF >> "./html-files/${index}.html"
<pre class="${pre_class}" $@>
${code_tag}
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</code>
</pre>
EOF
	fi
}

# requires path to page
# optional begin/end
# optional css style name
# optional multiple attributes
function generate_html_div {
	local page="${1%.*}"
	page="${page##*/}"
	local side="${2:-begin}"
	local css_style="$3"
	local div_tag

	if [ -n "$css_style" ]
	then
		shift 3
		div_tag="<div class=\"${css_style}\" $@>"
	else
		div_tag="<div>"
	fi

	if [ "$side" = "begin" ]
	then
		cat << EOF >> "./html-files/${index}.html"
${div_tag}
EOF
	else
		cat << EOF >> "./html-files/${index}.html"
</div>
EOF
	fi
}

# requires path to page
function generate_html_break {
	echo "<br />" >> "./html-files/${index}.html"
}

# requires path to page
function generate_html_breaker {
	echo "<hr />" >> "./html-files/${index}.html"
}

# requires path to page
# requires link
# requires title
# optional css class
function generate_html_link {
	local page="${1%.*}"
	page="${page##*/}"
	local link="${2:-#}"
	local title="${3:-link}"
	local class="$4"

	if [ -n "$class" ]
	then
		echo "<a class=\"${class}\" href=\"$link\">$title</a>" >> "./html-files/${index}.html"
	else
		echo "<a href=\"$link\">$title</a>" >> "./html-files/${index}.html"
	fi
}

# requires path to page
# requies text
# optional command
function generate_html_text {
	local page="$1"
	local text="$2"
	local style="$3"
	local tag=

	if [ -n "$style" ]
	then
		tag="<p class=\"${style}\">"
	else
		tag="<p>"
	fi

	echo "${tag}${text}</p>" >> "./html-files/${index}.html"
}

# requires path to page
# optional begin/end
# optional css class
# optional css style
function generate_html_list {
	local page="$1"
	local side="${2:-begin}"
	local class="$3"
	local style="$4"
	local tag=

	if [ "$side" = "begin" ]
	then
		if [ -n "$class" ]
		then
			if [ -n "$style" ]
			then
				tag="<ul class=\"${class}\" style=\"${style}\">"
			else
				tag="<ul class=\"${class}\">"
			fi
		else
			tag="<ul>"
		fi

		echo "${tag}${text}" >> "./html-files/${index}.html"
	elif [ "$side" = "end" ]
	then
		echo "</ul>" >> "./html-files/${index}.html"
	fi
}

# requires path to page
# optional begin/end
# optional css class
# optional css style
function generate_html_ordered_list {
	local page="$1"
	local side="${2:-begin}"
	local class="$3"
	local style="$4"
	local tag=

	if [ "$side" = "begin" ]
	then
		if [ -n "$class" ]
		then
			if [ -n "$style" ]
			then
				tag="<ol class=\"${class}\" style=\"${style}\">"
			else
				tag="<ol class=\"${class}\">"
			fi
		else
			tag="<ol>"
		fi

		echo "${tag}${text}" >> "./html-files/${index}.html"
	elif [ "$side" = "end" ]
	then
		echo "</ol>" >> "./html-files/${index}.html"
	fi
}

# requires path to page
# optional begin/end
# optional css class
# optional css style
function generate_html_nav {
	local page="$1"
	local side="${2:-begin}"
	local class="$3"
	local tag=

	if [ "$side" = "begin" ]
	then
		if [ -n "$class" ]
		then
			tag="<nav aria-label=\"${class}\">"
		else
			tag="<nav>"
		fi

		echo "${tag}${text}" >> "./html-files/${index}.html"
	elif [ "$side" = "end" ]
	then
		echo "</nav>" >> "./html-files/${index}.html"
	fi
}

# requires path to page
# required text
# optional class
# optional multiple attributes
function generate_html_item {
	local page="$1"
	local text="$2"
	local class="$3"
	local tag=
	local tag_end="</li>"

	if [ -n "$class " ]
	then
		shift 3
		tag="<li class=\"${class}\" $@>"
	else
		tag="<li>"
	fi

	echo "${tag}${text}${tag_end}" >> "./html-files/${index}.html"
}

# requires path to page
# required text
# optional address
# optional class
# optional link class
function generate_html_item_with_link {
	local page="$1"
	local text="$2"
	local address="$3"
	local class="$4"
	local link_class="$5"
	local tag=
	local tag_end="</li>"

	if [ -n "$class " ]
	then
		tag="<li class=\"${class}\">"
	else
		tag="<li>"
	fi

	if [ -n "$address" ]
	then
		if [ -n "$link_class" ]
		then
			tag="${tag}<a class=\"${link_class}\" href=\"${address}\">"
		else
			tag="${tag}<a href=\"${address}\">"
		fi
		tag_end="</a></li>"
	else
		tag_end="</li>"
	fi

	echo "${tag}${text}${tag_end}" >> "./html-files/${index}.html"
}

# requires path to page
# requires begin/end
function generate_list_group_root {
	local path="$1"
	local side="${2:-begin}"

	generate_html_div "$path" "$side" "list-group list-group-root well"
}

# requires path to page
# requires begin/end
# requires id
function generate_list_group {
	local path="$1"
	local side="${2:-begin}"
	local id="$3"

	generate_html_div "$1" "$side" "list-group collapse" "id=\"${id}\""
}

# requires local link
# requires title
# requires link (not implemented yet)
function generate_list_group_collapse_item {
	local link="${1}"
	local title="${2}"

#<a href="${link/-/.}.html">Visit</a>
	cat << EOF >> "./html-files/${index}.html"
<a href="#${link}" class="list-group-item" data-toggle="collapse">
	<i class="glyphicon glyphicon-chevron-right"></i>${title}
</a>
EOF
}

# requires local link
# requires title
# requires link (not implemented yet)
function generate_list_group_item {
	local link="${1}"
	local title="${2}"

	generate_html_link "$1" "$link" "$title" list-group-item
}

# required functions for managing practice pages
###############################################################################

# requires path to page
function extract_configuration {
	if [ -f "${1%.*}.config" ]
	then
		sed -i 's/^#\([^#]\)/\1/' "${1%.*}.config"
	fi
}

# requires absolute path to page
function generate_configuration {
	local page

	if [ -f "$1" ]
	then
		page="${1%.*}.config"
	elif [ -d "$1" ]
	then
		page="${1%/}/.config"
	else
		tput bold
		echo "invalid location to create config file: $1" >&2
		tput sgr0
		return 1
	fi

	cat << EOF > "$page"
$main_configuration
EOF
}

# requires path to config
function regenerate_configuration {
	if [ "${1##*.}" != "config" ]
	then
		tput bold
		echo "invalid configuration to regenerate"
		tput sgr0
		return 1
	fi

	local line=
	local config=
	local value=
	local target_config="$(grep '^[^# ]' "$1")"

	generate_configuration "$1"

	while read -r line
	do
		config="${line%%=*}"
		value="${line#*=}"
		value="${value%%#*}"
		sed -i "/^#${config}=/s/^#\(${config}\)=.*/\1=${value}/" "$1"
	done <<< "$target_config"
}

# requires path to page
function validate_page {
	local page=
	local extension=

	for extension in title.txt comment.txt reference.txt config
	do
		page="${1%.*}.${extension}"

		if ! [ -f "$page" ]
		then
			if [ "$extension" = "config" ]
			then
				generate_configuration "$1"
			else
				touch "$page"
			fi
		else
			if [ "$extension" = "config" ]
			then
				regenerate_configuration "$page"
			fi
		fi
	done
}

# requires path to chapter
function validate_chapter {
	local page=
	local extension=

	if ! [ -f "${1%/}/.index" ]
	then
		echo "README.md" > "${1%/}/.index"
	elif [ "$(head -n1 "${1%/}/.index")" != "README.md" ]
	then
		sed -i -e '/README.md/d' -e '1i README.md' "${1%/}/.index"
	fi

	regenerate_configuration "${1%/}/.config"

	for extension in md config title.txt comment.txt reference.txt
	do
		page="${1%/}/README.${extension}"

		if [ "$extension" = "config" ]
		then
			if ! [ -f "${1%/}/.config" ]
			then
				# configuration for chapter
				generate_configuration "$1"
			fi
			# configuration for readme file
			echo "EXECUTABLE=false" > "$page"
			echo "SOURCE=false" >> "$page"
			echo "INPUT=false" >> "$page"
			echo "OUTPUT=false" >> "$page"
		elif ! [ -f "$page" ]
		then
			if [ "$extension" = "md" ]
			then
				echo -e "# Practice Repository\n" > "$page"
				echo -n "This file is automatically created by " >> "$page"
				echo -n "<b>Practice Manager</b> " >> "$page"
				echo -n "and is part of the " >> "$page"
			   	echo -n "<a href=\"https://github.com/briansalehi/milestone.git\">" >> "$page"
				echo -n "<b>Milestone</b></a> project." >> "$page"
			else
				touch "$page"
			fi
		fi
	done
}

# requires relative path to list
function validate_configuration {
	local directory="${1%/*}"
	local members
	local line
	local file

	if ! [ -f "$1" ]
	then
		tput bold
		echo "unindexed directory: $directory/" >&2
		tput sgr0
		return 1
	fi

	while read -r line
	do
		line="${line%% *}"
		if [ -f "$directory/$line" ]
		then
			validate_page "$directory/$line"
		elif [ -d "$directory/$line" ]
		then
			validate_chapter "$directory/$line"
			if ! validate_configuration "$directory/$line/.index"
			then
				return 1
			fi
		else
			tput bold
			echo "missing entry: $directory/$line" >&2
			tput sgr0
		fi
	done < "$1"
}

# requires absolute path to source to configure corresponding variables
function update_configuration {
	local directory
	local config

	for level in ${1//\//$'\n'}
	do
		if [ -d "$directory$level" ]
		then
			directory="$directory$level/"
		elif [ -f "$directory$level" ]
		then
			directory="$directory${level%.*}"
		fi

		config="$directory.config"

		if [ -f "$config" ]
		then
			source "$config"
		fi
	done
}

# requires path to page
# requires compile/link/run option
# requires command
# optional syntax
function generate_execution_mode {
	local page="${1}"
	local mode="${2:-compile}"
	local command="${3}"
	local syntax="${4:-practices}"

	if [ -z "$command" ]
	then
		tput bold
		echo "execution command not specified: $page"
		tput sgr0
		return 1
	fi

	generate_html_header "$1" 4 "${mode}"
	generate_html_code "$1" begin "command-line" "language-bash" "data-user=\"${syntax}\" data-host=\"milestone\""
	echo "$command" >> "./html-files/${index}.html"
	generate_html_code "$1" end
}

# requires absolute path to source
# option headers and required files
function compile_source {
	local source="$1"
	local page="${1%.*}"
	page="${page##*/}"
	local location="${1%/*}"

	update_configuration "$1"

	if [ "${EXECUTABLE:-true}" != "true" ]
	then
		return 1
	fi

	local syntax=
	if [ -n "$LANGUAGE" ]
	then
		syntax="$LANGUAGE"
	else
		syntax="${1##*.}"
	fi

	generate_html_header "$1" 3 "Execution"

	local binary="${1%.*}.bin"
	OUTPUT_OBJECT="${OUTPUT_OBJECT:-o}"
	local object="${1%.*}.${OUTPUT_OBJECT#.}"
	local headers="$@"
	headers="${headers/$1 }"
	local includes=
	local output="${1%.*}.output.txt"
	local execution_command
	local output_change_time
	local source_change_time
	local component=

	if [ "${COMPILABLE:-true}" = "true" ] && [ -z "$COMPILER" ]
	then
		tput bold
		echo "compiler not specified for: $1" >&2
		tput sgr0
		return 1
	fi

	if [ "${INCLUDES:-false}" != "true" ]
	then
		headers=
	fi

	source_change_time=$(stat -c "%Y" "$1")

	if [ -f "$output" ]
	then
		output_change_time=$(stat -c "%Y" "$output")
	else
		output_change_time=0
	fi

	# build compilation scheme
	execution_command=
	for component in ${COMPILATION_SCHEME:-compiler options object source}
	do
		case "$component" in
			compiler) execution_command+="$COMPILER " ;;
			options) execution_command+="$COMPILER_OPTIONS " ;;
			object) execution_command+="$object " ;;
			source) execution_command+="$source " ;;
			binary) execution_command+="$binary " ;;
			headers) execution_command+="$headers " ;;
			page) execution_command+="$page " ;;
			location) execution_command+="$location " ;;
			*)
				tput bold
				echo "invalid scheme component: $component" >&2
				tput sgr0
				return 1
				;;
		esac
	done
	execution_command="${execution_command//  / }"
	execution_command="${execution_command% }"

	if ! [ -f "$output" ] || [ "$source_change_time" -ge "$output_change_time" ]
	then
		if [ "${COMPILABLE:-true}" = "true" ]
		then
			if ! $execution_command
			then
				tput bold
				echo "compilation error: $1" >&2
				echo "  command: $execution_command" >&2
				tput sgr0
			fi
		else
			if [ -f "$binary" ]
			then
				unlink "$binary"
			fi
			ln -s "$PWD/${1/\.\//}" "${binary}"
		fi
	fi

	if [ "${COMPILABLE:-true}" = "true" ]
	then
		execution_command="${execution_command//$location/}"
		generate_execution_mode "$1" compile "$execution_command" "$syntax"
	fi

	# build linkage scheme
	execution_command=
	for component in ${LINKAGE_SCHEME:-linker options binary object headers}
	do
		case "$component" in
			linker) execution_command+="$LINKER " ;;
			options) execution_command+="$LINKER_OPTIONS " ;;
			object) execution_command+="$object " ;;
			binary) execution_command+="$binary " ;;
			headers) execution_command+="$headers " ;;
			source) execution_command+="$source " ;;
			page) execution_command+="$page " ;;
			location) execution_command+="$location " ;;
			*)
				tput bold
				echo "invalid scheme component: $component" >&2
				tput sgr0
				return 1
				;;
		esac
	done
	execution_command="${execution_command//  / }"
	execution_command="${execution_command% }"

	if [ "${LINKABLE:-true}" = "true" ] && ! [ -f "$output" ]\
	   	|| [ "$source_change_time" -ge "$output_change_time" ]
	then
		if [ "${LINKABLE:-true}" = "true" ] && [ -n "$LINKER" ]
		then
			if ! $execution_command
			then
				tput bold
				echo "linkage error for: $1" >&2
				echo "  command: $execution_command" >&2
				tput sgr0
			fi
		elif [ "${LINKABLE:-true}" = "true" ] && [ -z "$LINKER" ]
		then
			tput bold
			echo "linker not specified for: $1" >&2
			tput sgr0
			return 1
		fi
	fi

	if [ "${LINKABLE:-true}" = "true" ]
	then
		execution_command="${execution_command//$location/}"
		generate_execution_mode "$1" link "$execution_command" "$syntax"
	fi
}

# requires path to page
# optional floor to start indexing directories
# sets page_index and page_hierarchy variables
function index_page {
	local floor="${2:-1}"

	local depth=1
	local entry=
	local hierarchy=
	local index=
	page_index=
	page_hierarchy=

	for entry in ${1//\//$'\n'}
	do
		hierarchy="${hierarchy:-$entry}"

		if [ "$depth" -gt "$floor" ]
		then
			match="$(grep -n "^$entry" "${hierarchy}/.index")"
			match="${match%%:*}"
			match="${match%% *}"
			((match--)) # shift index down because of readme indexes
			index+="${match}."
		fi

		((depth++))
		hierarchy="${hierarchy}/${entry}"
	done
	page_index="${index%.}"
	page_hierarchy="${hierarchy#\.\/}"
}

# requires path to page
# optional up/down for direction of growth
# sets deepest_page variable
function deepest_path {
	local hierarchy="${1%/}"
	local direction="${2:-up}"

	local entry=
	local tool=
	deepest_page=

	if [ "$direction" = "up" ]
	then
		tool="head"
	elif [ "$direction" = "down" ]
	then
		tool="tail"
	else
		return 1
	fi

	while true
	do
		if [ -d "$hierarchy" ] && [ -f "${hierarchy}/.index" ]
		then
			entry="$("$tool" -n1 "${hierarchy}/.index")"
			entry="${entry%% *}"
			if [ -n "$entry" ]
			then
				hierarchy="${hierarchy}/${entry}"
			else
				break
			fi
		else
			break
		fi
	done
	deepest_page="$hierarchy"
}

# requires path to page
# optional up/down for direction of growth
# sets page_index and page_hierarchy variables
# note: empty variables means there is no neighbor
function nearest_path {
	local hierarchy="${1%/}"
	local page="${hierarchy##*/}"
	hierarchy="${hierarchy%/*}"
	local direction="${2:-up}"
	local match=
	local option=

	if [ "$direction" = "up" ]
	then
		option="-B1"
	elif [ "$direction" = "down" ]
	then
		option="-A1"
	else
		return 1
	fi

	while [ "$hierarchy" != "." ]
	do
		match="$(grep "$option" "^$page" "${hierarchy}/.index")"

		if [ "$direction" = "up" ]
		then
			match="${match%$'\n'*}"
		else
			match="${match#*$'\n'}"
		fi
		match="${match%% *}"

		if [ "$match" = "$page" ]
		then
			page="${hierarchy##*/}"
			hierarchy="${hierarchy%/*}"
		else
			if [ "$direction" = "up" ]
			then
				direction="down"
			else
				direction="up"
			fi

			if [ -d "${hierarchy}/${match}" ]
			then
				deepest_path "${hierarchy}/${match}" "$direction"
				page="$deepest_page"
			else
				page="${hierarchy}/${match}"
			fi

			index_page "$page"
			break
		fi
	done

	if [ "$hierarchy" = "." ]
	then
		page_index=
		page_hierarchy=
	fi
}

# requies process id to kill
# requies seconds to wait before strike
function process_kill {
	sleep "$2"
	kill -SIGTERM "$1"
}

# requires path to page
function run_program {
	local source="$1"
	OUTPUT_OBJECT="${OUTPUT_OBJECT:-o}"
	local object="${1%.*}.${OUTPUT_OBJECT#.}"
	local headers="$@"
	headers="${headers/$1 }"
	local output="${1%.*}.output.txt"
	local location="${1%/*}"
	local component=

	if [ "${RUNNABLE:-true}" != "true" ]
	then
		return 0
	fi

	update_configuration "$1"

	# build running scheme
	local running_command=
	for component in ${RUNNING_SCHEME:-binary options}
	do
		case "$component" in
			compiler) running_command+="$COMPILER " ;;
			linker) running_command+="$LINKER " ;;
			options) running_command+="$RUNNING_OPTIONS " ;;
			object) running_command+="$object " ;;
			source) running_command+="$source " ;;
			binary) running_command+="$binary " ;;
			headers) running_command+="$headers " ;;
			page) running_command+="$page " ;;
			location) running_command+="$location " ;;
			*)
				tput bold
				echo "invalid scheme component: $component" >&2
				tput sgr0
				return 1
				;;
		esac
	done
	execution_command="${execution_command//  / }"
	running_command="${running_command% }"

	generate_execution_mode "$1" run "$running_command" "$LANGUAGE"

	if [ -f "$input" ]
	then
		if ! $running_command < "$input" > "$output"
		then
			tput bold
			echo "running program failed: $source" >&2
			echo "  command: $running_command" >&2
			tput sgr0
		fi
	else
		if ! $running_command > "$output"
		then
			tput bold
			echo "running program failed: $source" >&2
			echo "  command: $running_command" >&2
			tput sgr0
		fi
	fi
}

# functions to generate html pages
###############################################################################

# requires path to page
function generate_breadcrumb_section {
	local hierarchy=
	local entry=
	local page=
	local title=
	local local_index=

	generate_html_ordered_list "$1" begin breadcrumb

	for entry in ${1//\//$'\n'}
	do
		if [ -z "$hierarchy" ]
		then
			hierarchy="$entry"
			continue
		fi

		hierarchy="${hierarchy}/${entry}"

		if [ -d "$hierarchy" ] && [ -f "${hierarchy}/README.title.txt" ]
		then
			if [ "${hierarchy}/README.md" != "$1" ]
			then
				title="$(cat "${hierarchy}/README.title.txt")"
				local_index="$hierarchy"
				local_index="${local_index//[^\/]/}"
				local_index="${#local_index}"
				page="$(cut -d"." -f1-"$local_index" <<< "$page_index").0.html"
				generate_html_item_with_link "$1" "${title:-"..."}" "$page" breadcrumb-item
			fi
		elif [ -f "$hierarchy" ] && [ -f "${hierarchy%.*}.title.txt" ]
		then
			title="$(cat "${hierarchy%.*}.title.txt")"
			generate_html_item "$1" "${title:-"..."}" "breadcrumb-item active"
		else
			tput bold
			echo "untitled breadcrumb: ${hierarchy}"
			tput sgr0
			generate_html_item "$1" "..." breadcrumb-item
		fi
	done

	generate_html_ordered_list "$1" end
}

function generate_index_section {
	local tag="<h1>"

	echo -n "  ${tag}${index%.0}. " >> "./html-files/${index}.html"
}

# requires path to page
function generate_header_section {
	local page="${1%.*}"
	local header="$page.title.txt"
	page="${page##*/}"
	local title

	if ! [ -f "$header" ]
	then
		tput bold
		echo "header not found: $header" >&2
		tput sgr0
	elif [ -z "$(cat "$header")" ]
	then
		tput bold
		echo "empty header: $header" >&2
		tput sgr0
	else
		title="$(cat "$header")"
		generate_html_header "$1" 2 "$title"
	fi
}

# requires path to page
function generate_page_name {
	local tag="<cite>"
	local tag_end="</cite>"

	echo "  ${tag}${1##*/}${tag_end}" >> "./html-files/${index}.html"
}

# requires path to page
function generate_source_section {
	update_configuration "$1"

	if [ "$SOURCE" != "true" ]
	then
		return 1
	fi

	generate_html_breaker "$1"
	generate_html_header "$1" 3 "Source"
	while [ $# -gt 0 ]
	do
		generate_page_name "${1}"

		local syntax=
		if [ -n "$LANGUAGE" ]
		then
			syntax="$LANGUAGE"
		else
			syntax="${1##*.}"
		fi

		generate_html_code "$1" begin "line-numbers" "language-${syntax}"
		OLD_IFS="$IFS"
		IFS=
		local line
		while read -r line
		do
			line="${line//&/&amp;}"
			line="${line//\"/&quot;}"
			line="${line//\'/&apos;}"
			line="${line//</&lt;}"
			line="${line//>/&gt;}"
			echo "    $line" >> "./html-files/${index}.html"
		done < "$1"
		IFS="$OLD_IFS"
		generate_html_code "$1" end
		shift
	done
}

# requires absolute path to page
function generate_output_section {
	local page="${1%.*}"
	local binary="$page.bin"
	local output="$page.output.txt"
	local input="$page.input.txt"
	page="${page##*/}"
	local line

	if ! compile_source $@
	then
		return 1
	fi

	if ! run_program "$1" $@
	then
		return 1
	fi

	if [ "${INPUT:-true}" = "true" ] && [ -f "$input" ]
	then
		generate_html_header "$1" 3 Input
		while read -r line
		do
			generate_html_text "$1" "$line"
		done < "$input"
	fi

	if [ "${OUTPUT:-true}" = "true" ]
	then
		if [ -f "$output" ] && [ "$(wc -w < "$output")" -gt 0 ]
		then
			generate_html_header "$1" 3 Output

			while read -r line
			do
				generate_html_text "$1" "$line"
			done < "$output"

			if [ "$(wc -l < "$output")" -eq 0 ]
			then
				echo >> "$output"
			fi
		elif [ -f "$output" ]
		then
			rm "$output"
		else
			tput bold
			echo "output file not found: $output" >&2
			tput sgr0
		fi
	fi
}

# requires absolute path to page
function generate_comment_section {
	update_configuration "$1"

	if [ "$COMMENTS" != "true" ]
	then
		return 1
	fi

	local page="${1%.*}"
	local comment="$page.comment.txt"
	page="${page##*/}"

	if ! [ -f "$comment" ]
	then
		tput bold
		echo "comment not found: $comment" >&2
		tput sgr0
	elif [ -z "$(cat "$comment")" ]
	then
		tput bold
		echo "empty comment: $comment" >&2
		tput sgr0
	else
		generate_html_div "$1" begin comment-style
		OLD_IFS="$IFS"
		local line
		while read -r line
		do
			line="$(echo "$line" | sed -e 's/\([\.,!?;:]\)$/\1<br \/>/' -e 's/^$/<br \/>/')"
			echo -e "   $line" >> "./html-files/${index}.html"
		done < "$comment"
		IFS="$OLD_IFS"
		generate_html_div "$1" end
	fi
}

# requires absolute path to page
function generate_quick_access_section {
	local page="${1%.*}"
	page="${page##*/}"
	local next_index=
	local previous_index=
	local button=

	nearest_path "$1" up
	previous_index="$page_index"

	nearest_path "$1" down
	next_index="$page_index"

	#generate_html_nav "$1" begin "Practice Navigation"
	generate_html_list "$1" begin pager

	#button="<span aria-hidden="true">&larr;</span> "
	button="previous page"
	if [ -n "$previous_index" ]
	then
		# alternative classes: page-item page-link
		generate_html_item_with_link "$1" "$button" "${previous_index}.html" previous
	else
		generate_html_item_with_link "$1" "$button" "#" "previous disabled"
	fi

	#button="<span aria-hidden="true">&uarr;</span> "
	button="top page"
	if [ -z "$previous_index" ] || [ -z "$next_page" ]
	then
		generate_html_item_with_link "$1" "$button" "index.html" top
	fi

	#button="<span aria-hidden="true">&rarr;</span>"
	button="next page"
	if [ -n "$next_index" ]
	then
		generate_html_item_with_link "$1" "$button" "${next_index}.html" next
	else
		generate_html_item_with_link "$1" "$button" "#" "next disabled"
	fi

	generate_html_list "$1" end
	#generate_html_nav "$1" end
}

function generate_table_of_content {
	local hierarchy="${1%/*}"
	local entry=
	local indentation=
	local local_index=
	local title=

	while read -r entry
	do
		entry="${entry%% *}"
		if [ -d "${hierarchy}/${entry}" ] || [ "$entry" = "README.md" ]
		then
			if [ "$entry" = "README.md" ]
			then
				index_page "${hierarchy}/${entry}"
				if [ "$page_index" = "0" ]
				then
					title="$(cat "${hierarchy}/${entry%.*}.title.txt")"
					generate_html_header_with_link "$1" 3 "$title" "${page_index}.html"
					generate_html_breaker "$1"
					generate_html_header "$1" 4 "Table of Content"
					generate_list_group_root "$1" begin
				else
					title="${page_index%.0}. $(cat "${hierarchy}/${entry%.*}.title.txt")"
					#generate_html_item_with_link "$1" "$title" "${page_index}.html"
					generate_list_group_collapse_item "${page_index//./-}" "$title"
					generate_list_group "$1" begin "${page_index//./-}"
				fi
			elif [ -f "${hierarchy}/${entry%/}/.index" ]
			then
				#generate_html_list "$1" begin
				generate_table_of_content "${hierarchy}/${entry%/}/.index"
				generate_list_group "$1" end
				#generate_html_list "$1" end
			else
				tput bold
				echo "broken hierarchy in ${hierarchy}/${entry%/}/.index"
				tput sgr0
			fi
		elif ! [ -f "${hierarchy}/${entry}" ]
		then
			tput bold
			echo "missing entry in table of content: ${hierarchy}/${entry}"
			tput sgr0
			return 1
		elif ! [ -f "${hierarchy}/${entry%.*}.title.txt" ]
		then
			tput bold
			echo "missing entry title in table of content: ${hierarchy}/{$entry}"
			tput sgr0
			return 2
		else
			#generate_html_list "$1" begin
			index_page "${hierarchy}/${entry}"
			title="${page_index%.0}. $(cat "${hierarchy}/${entry%.*}.title.txt")"
			generate_list_group_item "${page_index}.html" "$title"
			#generate_html_item_with_link "$1" "$title" "${page_index}.html"
			#generate_html_list "$1" end
		fi
	done < "${hierarchy}/.index"
}

function generate_index_page {
	local page="./html-files/index.html"
	index=index

	generate_html_section "$page" begin
	generate_html_head "$page" begin
	generate_html_style "$page" begin
	generate_html_style "$page" begin nested-list
	generate_html_style "$page" end
	generate_html_head "$page" end
	generate_html_body "$page" begin
	generate_html_div "$page"
	generate_table_of_content "./.index"
	generate_list_group_root "$1" end
	generate_html_div "$page" end
	generate_html_script "$page" begin
	generate_html_script "$page" begin nested-list
	generate_html_script "$page" end
	generate_html_body "$page" end
	generate_html_section "$page" end
}

# functions to start the script working
###############################################################################

# requires path to page
function generate_page {
	index_page "$1"
	index="$page_index"
	generate_html_section "$1" begin
	generate_html_head "$1" begin
	generate_html_style "$1" begin
	generate_html_style "$1" end
	generate_html_head "$1" end
	generate_html_body "$1" begin
	generate_html_div "$1" begin container
	generate_breadcrumb_section "$1"
	generate_header_section "$1"
	generate_comment_section "$1"
	generate_source_section $@
	generate_output_section $@
	generate_quick_access_section "$1"
	generate_html_div "$1" end container
	generate_html_script "$1" begin
	generate_html_script "$1" end
	generate_html_body "$1" end
	generate_html_section "$1" end
	index=
}

# requires absolute path to page
function generate_chapter {
	index_page "$1/README.md"
	index="$page_index"
	generate_html_section "$1/README.md" begin
	generate_html_head "$1/README.md" begin
	generate_html_head "$1/README.md" end
	generate_html_body "$1/README.md" begin
	generate_html_style "$1" begin
	generate_html_style "$1" end
	generate_breadcrumb_section "$1"
	generate_header_section "$1/README.md"
	generate_comment_section "$1/README.md"
	generate_quick_access_section "$1/README.md"
	generate_html_script "$1" begin
	generate_html_script "$1" end
	generate_html_body "$1/README.md" end
	generate_html_section "$1/README.md" end
	index=
}

# requires relative path to list
function expand_list {
	local directory
	local members
	local group

	directory="${1%/*}"

	if ! [ -f "$1" ]
	then
		tput bold
		echo "unindexed directory: $directory/" >&2
		tput sgr0
		return 1
	fi

	local line
	while read -r line
	do
		members="${line//[^\ ]/}"

		if [ "${#members}" -gt 0 ]
		then
			for file in $line
			do
				if [ -f "$directory/$file" ]
				then
					group="$group $directory/$file"
				else
					tput bold
					echo "missing group member: $directory/$file" >&2
					tput sgr0
					continue 2
				fi
			done
			generate_page $group
		elif [ -f "$directory/$line" ]
		then
			generate_page "$directory/$line"
		elif [ -d "$directory/$line" ]
		then
			expand_list "$directory/$line/.index"
		else
			tput bold
			echo "missing entry: $directory/$line" >&2
			tput sgr0
		fi
		group=
	done < "$1"
}

# requires full path to first index file to recusrively build document
# must be called with trailing ./ in first argument
function generate_manuals {
	if [ -d ./html-files/ ]
	then
		rm -r ./html-files/
	fi

	mkdir ./html-files/

	if expand_list "$1"
	then
		generate_index_page

		# include bootstrap
		if [ -f "bootstrap.min.css" ] && [ -f "bootstrap.min.js" ]
		then
			cp bootstrap.min.* html-files/
		fi
	fi
}

# functions for specific options
###############################################################################

# requires path to location where practice will be added
function add_page {
	local location="${1%/*}"
	local practice_name="${1##*/}"

	if [ -z "$location" ]
	then
		tput bold
		echo "location not given" >&2
		tput sgr0
		return 1
	elif [ -z "$practice_name" ]
	then
		tput bold
		echo "practice name not given" >&2
		tput sgr0
		return 1
	elif ! [ -d "$location" ]
	then
		tput bold
		echo "location must be a directory: $location" >&2
		tput sgr0
		return 1
	elif [ $(grep -c "^$practice_name$" "${location}/.index") -gt 0 ]
	then
		tput bold
		echo "duplicate practice name: $practice_name" >&2
		tput sgr0
	fi

	# index practice in corresponding location
	echo "$practice_name" >> "${location}/.index"

	# create practice file itself
	touch "${location}/${practice_name}"
	# create additional files within source
	validate_page "${location}/${practice_name}"
}

# requires path to location where chapter will be added
function add_chapter {
	local location="${1%/*}"
	local chapter_name="${1##*/}"

	if [ -z "$location" ]
	then
		tput bold
		echo "location not given" >&2
		tput sgr0
		return 1
	elif [ -z "$chapter_name" ]
	then
		tput bold
		echo "practice name not given" >&2
		tput sgr0
		return 1
	elif ! [ -d "$location" ]
	then
		tput bold
		echo "location must be a directory: $location" >&2
		tput sgr0
		return 1
	fi

	# if the holding directory itself does not have .index create one!
	if ! [ -f "${location}/.index" ] || [ "$(wc -l < "${location}/.index")" -eq 0 ]
	then
		generate_configuration "${location}"
		extract_configuration "${location}"
		echo "README.md" > "${location}/.index"
		validate_chapter "${location}"
	fi
	echo "$chapter_name" >> "${location}/.index"

	mkdir "${location}/${chapter_name}"
	validate_chapter "${location}/${chapter_name}"
}

# requires relative path to practice location
function join_page {
	# index page
	echo "${1##*/}" >> "${1%/*}/.index"

	# check if necessary files exist within page itself
	validate_page "$1"
}

function join_chapter {
	# index chapter
	echo "${1##*/}" >> "${1%/*}/.index"

	validate_chapter "$1"
}

# requires path to page
function remove_page {
	local page="${1%.*}"
	local location="${1%/}"
	location="${location%/*}"

	if [ -f "$1" ]
	then
		rm "$page."*
		page="${page##*/}"
		if [ -f "${location}/.index" ]
		then
			sed -i "/${page}/d" "${location}/.index"
		fi
		echo "practice removed: ${1/$PWD\//}"
	else
		tput bold
		echo "practice page does not exist: ${1/$PWD\//}" >&2
		tput sgr0
		return 1
	fi
}

# requires path to directory
function remove_chapter {
	local location="${1%/}"
	location="${location%/*}"
	local chapter="${1%/}"
	chapter="${chapter##*/}"

	if [ -d "$1" ]
	then
		rm -r "$1"
		if [ -f "${location}/.index" ]
		then
			sed -i "/${chapter}/d" "${location}/.index"
		fi
		echo "chapter removed: ${1/$PWD\//}"
	else
		tput bold
		echo "chapter does not exist: ${1/$PWD\//}" >&2
		tput sgr0
		return 1
	fi
}

function rename_page {
	local source="${1%.*}"
	local destination="${2%.*}"
	local match=

	for match in $(find "${source%/*}" -type f -name "${source##*/}*")
	do
		mv "$match" "${source%/*}/${destination##*/}${match##*.}"
	done

	sed -i "s/^${1##*/}$/${2##*/}/" "${1%/*}/.index"
}

function rename_chapter {
	local source="${1%/}"
	local destination="${2%/}"

	if mv "$source" "$destination"
	then
		sed -i "s/^${source##*/}$/${destination##*/}/" "${source%/*}/.index"
	else
		tput bold
		echo "failed to rename chapter: $source" >&2
		tput sgr0
		return 1
	fi
}

function move_page {
	local source="$1"
	local destination="$2"

	if [ -f "$destination" ] && [ -f "${source%/*}/.index" ]
	then
		local match=
		source="${1%.*}"
		destination="${2%.*}"
		for match in $(find "${source%/*}" -type f -name "${source##*/}*")
		do
			mv "$match" "${destination%/*}/${destination##*/}${match##*.}"
		done

		sed -i "s/^${1##*/}$/${2##*/}/" "${1%/*}/.index"
		echo "${2##*/}" >> "${2%/*}/.index"

	elif [ -d "$destination" ] && [ -f "${source%/}/.index" ]
	then
		if mv "${source%.*}*" "$destination"
		then
			sed -i "/^${source##*/}$/d" "${source%/*}/.index"
			join_page "${destination%/}/${source##*/}"
		else
			tput bold
			echo "failed to move source: $source" >&2
			tput sgr0
			return 1
		fi
	else
		tput bold
		echo "page not indexed: $source" >&2
		tput sgr0
		return 1
	fi
}

function move_chapter {
	local source="${1%/}"
	local destination="${2%/}"
	local local_index=

	if [ -n "$3" ]
	then
		local_index="$3"
		((local_index++)) # indexing starts from zero for readme files
	fi

	if ! [ -d "$source" ] && [ -d "${destination%/*}" ]
	then
		tput bold
		echo "source or destination does not exist!" >&2
		tput sgr0
		return 1
	fi

	if [ -d "$destination" ]
	then
		if mv "$source" "$destination"
		then
			sed -i "/^${source##*/}$/d" "${source%/*}/.index"
			if [ -n "$local_index" ]
			then
				sed -i "${local_index}i ${source##*/}" "${destination}/.index"
			else
				echo "${source##*/}" >> "${destination}/.index"
			fi
		else
			tput bold
			echo "failed to move!" >&2
			tput sgr0
		fi
	else
		if mv "$source" "$destination"
		then
			sed -i "/^${source##*/}$/d" "${source%/*}/.index"
			if [ -n "$local_index" ]
			then
				sed -i "${local_index}i ${destination##*/}" "${destination%/*}/.index"
			else
				echo "${destination##*/}" >> "${destination%/*}/.index"
			fi
		else
			tput bold
			echo "failed to move!" >&2
			tput sgr0
		fi

	fi
}

function swap_page {
	local location="${1%/*}"
	local source_index="${1}"
	local destination_index="${2}"

	if [ "${1%/*}" = "${2%/*}" ]
	then
		if [ -f "${location}/.index" ]
		then
			source_index="$(grep -n "${1##*/}" "${location}/.index")"
			destination_index="$(grep -n "${2##*/}" "${location}/.index")"
			sed -i "${destination_index}d" "${location}/.index"
			sed -i "${destination_index}i ${1##*/}" "${location}/.index"
			sed -i "${source_index}d" "${location}/.index"
			sed -i "${source_index}i ${2##*/}" "${location}/.index"
		else
			tput bold
			echo "location not indexed: $location" >&2
			tput sgr0
			return 1
		fi
	else
		tput bold
		echo "locations are not equal: $location" >&2
		tput sgr0
		return 1
	fi
}

function swap_chapter {
	local source="${1%/}"
	local destination="${2%/}"
	local source_index=
	local destination_index=
	
	if [ -d "$source" ] && [ -d "$destination" ]
	then
		source_index="$(grep -n "^${source##*/}$" "${source%/*}/.index")"
		source_index="${source_index%%:*}"
		((source_index--))
		destination_index="$(grep -n "^${destination##*/}$" "${destination%/*}/.index")"
		destination_index="${destination_index%%:*}"
		((destination_index--))

		if [ "${source%/*}" = "${destination%/*}" ]
		then
			sed -i "s/^${destination##*/}$/chapter_name_substitution/" "${destination%/*}/.index"
			sed -i "s/^${source##*/}$/${destination##*/}/" "${source%/*}/.index"
			sed -i "s/chapter_name_substitution/${source##*/}/" "${destination%/*}/.index"
		else
			move_chapter "$1" "./temporary_source_chapter"
			move_chapter "$2" "./temporary_destination_chapter"
			move_chapter "$PWD/temporary_source_chapter" "${destination%/*}" "$destination_index"
			move_chapter "$PWD/temporary_destination_chapter" "${source%/*}" "$source_index"
		fi
	else
		tput bold
		echo "source or destination does not exist"
		tput sgr0
	fi
}

function touch_sources {
	find -type f -name ".index" -exec sh -c '
		directory="{}"
		while read -r file
		do
			for entry in "$file"
			do
				filename="${directory%/*}/$entry"
				if [ -f "$filename" ]
				then
					touch "$filename"
				fi
			done
		done < "{}"' \;
}

# requires path to page or chapter
function remove_files {
	if [ -f "./${1#\.\/}" ]
	then
		remove_page "./${1#\.\/}"
	else
		remove_chapter "./${1#\.\/}"
	fi
}

# requires path to source and destination
function move_files {
	local source="${1%/}"
	local destination="${2%/}"

	# source is a directory and destination doesn't have extension,
	if [ -d "${source}" ] && [ -z "$(sed -n 's/.*\.\([[:alnum:]]*\)$/\1/p' <<< "$destination")" ]
	then
		# locations exist
		if [ -d "${source%/*}" ] && [ -d "${destination%/*}" ]
		then
			# locations are similar
			if [ "${source%/*}" = "${destination%/*}" ]
			then
				# destination exists, swap chapter
				if [ -d "$destination" ]
				then
					echo "swapting chapter"
					swap_chapter "$source" "$destination"
				# destination does not exist, rename chapter
				else
					echo "renaming chapter"
					rename_chapter "$source" "$destination"
				fi
			# locations are not similar
			else
				# destination exists, move chapter to destination
				if [ -d "$destination" ]
				then
					echo "moving chapter"
					move_chapter "$source" "$destination"
				# destination does not exist, move chapter to destination location and rename source with destination
				else
					echo "moving and renaming chapter"
					move_chapter "$source" "$destination"
				fi
			fi
		else
			tput bold
			echo "invalid locations given:" >&2
			echo "  source: $source" >&2
			echo "  destination: $destination" >&2
			tput sgr0
			return 1
		fi
	# source is a file and destination has extension,
	elif [ -f "$source" ] && [ -n "$(sed -n 's/.*\.\([[:alnum:]]*\)$/\1/p' <<< "$destination")" ]
	then
		# locations are similar
		if [ "${source%/*}" = "${destination%/*}" ]
		then
			# destination exists, swap page
			if [ -f "$destination" ]
			then
				echo "swaping page"
				swap_page "$source" "$destination"
			# destination doesn't exist, rename page
			else
				echo "renaming page"
				rename_page "$source" "$destination"
			fi
		# locations are not similar
		else
			# destination exists, error cannot overwrite
			if [ -f "$destination" ]
			then
				tput bold
				echo "destination exists, cannot overwrite." >&2
				tput sgr0
				return 1
			# destination doesn't exist, move page to destination
			else
				echo "moving and renaming page"
				move_page "$source" "$destination"
			fi
		fi
	# source is a file and destination has extension,
	elif [ -f "$source" ] && [ -z "$(sed -n 's/.*\.\([[:alnum:]]*\)$/\1/p' <<< "$destination")" ]
	then
		# destination directory must exist
		if [ -d "${destination}" ]
		then
			echo "moving page"
			move_page "$source" "$destination"
		else
			tput bold
			echo "destination directory does not exist: $destination" >&2
			tput sgr0
			return 1
		fi
	# otherwise error invalid source
	else
		tput bold
		echo "invalid destination: $destination" >&2
		tput sgr0
		return 1
	fi
}

# requires path
function reorder_index {
	local location="./${1/\.\//}"
	local item=
	local index_file=
	local new_index=

	if [ -f "$location" ]
	then
		index_file="${location%/*}/.index"
	elif [ -d "$location" ]
	then
		index_file="${location%/*}/.index"
	else
		tput bold
		echo "invalid path: $location" >&2
		tput sgr0
		return 1
	fi

	if [ -f "$index_file" ]
	then
		PS3="Replace with: "
		select item in $(sed '1d' "$index_file" | xargs)
		do
			if [ -n "$item" ]
			then
				new_index="$REPLY"
				break
			fi
		done

		sed -i "/^${location##*/}$/d" "$index_file"
		sed -i "${new_index}a ${location##*/}" "$index_file"
	else
		tput bold
		echo "path not indexed: $index_file" >&2
		tput sgr0
		return 1
	fi
}

# requires path to chapter only
function list_index {
	echo "${1/\.\//}:"
	sed -n '2,$p' "${1%/}/.index" | nl
	echo
}

# requires relative path
function analyze_path {
	local path="${1%/}"
	local peek="${2:-false}"
	local extension="$(echo "$path" | sed -n 's/.*\.\([a-zA-Z]*\)$/\1/p')"

	# if does not have extension and exists and indexed: check all files within
	if [ -z "$extension" ] && [ -d "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 1 ]
	then
		validate_chapter "$path"
		if [ "$peek" = "true" ]
		then
			list_index "$path"
		fi
	# if does not have extension and exists but not indexed: check and join
	elif [ -z "$extension" ] && [ -d "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 0 ]
	then
		join_chapter "$path"
	# if does not have extension and does not exist: create chapter
	elif [ -z "$extension" ] && ! [ -d "$path" ]
	then
		add_chapter "$path"
	# if has extension and exists and indexed: check all files with it
	elif [ -n "$extension" ] && [ -f "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 1 ]
	then
		validate_page "$path"
	# if has extension and exists but is not indexed: check and join practice
	elif [ -n "$extension" ] && [ -f "$path" ] && [ -f "${path%/*}/.index" ]\
		&& [ "$(grep -c "^${path##*/}$" "${path%/*}/.index")" -eq 0 ]
	then
		join_page "$path"
	# if has extension but does not exist, create practice page
	elif [ -n "$extension" ] && ! [ -f "$path" ]
	then
		add_page "$path"
	# otherwise, unhandled error
	else
		return 1
	fi
}

function analyze_paramters {
	local source="${1#\.\/}"
	local destination="$2"

	if [ -z "$destination" ]
	then
		local hierarchy="."
		local entry=
		local peek=
		for entry in ${source//\//$'\n'}
		do
			hierarchy+="/$entry"

			# peek index of chapter if nothing happens
			if [ "${hierarchy}" = "./${1%/}" ]
			then
				peek=true
			else
				peek=false
			fi

			if ! analyze_path "${hierarchy/$PWD/}" "$peek"
			then
				tput bold
				echo "analyzing path failed: $path" >&2
				tput sgr0
			fi
		done
	else
		if ! move_files "./${1#\.\/}" "./${2#\.\/}"
		then
			tput bold
			echo "operation failed: $source" >&2
			tput sgr0
		fi
	fi
}

# Analyze Options and Paramters
###############################################################################

if [ -f ./.config ]
then
	validation_check=202012010254
	source ./.config
	if [ "${VALIDATION_ID:-0}" -lt "$validation_check" ]
	then
		tput bold
		echo "validating repository for new configuration..." >&2
		tput sgr0
		if ! validate_configuration "./.index"
		then
			echo "configuration failed"
			return 1
		fi
		regenerate_configuration "./.config"
		extract_configuration "./.config"
		sed -i "s/^\(VALIDATION_ID=\)[0-9]*$/\1${validation_check}/" ./.config
		echo "configuration complete, continuing..."
	fi
fi

if [ $# -eq 0 ]
then
	# At least one .index must exist at current directory
	# Everything starts here
	generate_manuals "./.index"
else
	case "$1" in
		-h|--help) usage ;;
		-r) remove_files "${2%/}" ;;
		-o) reorder_index "${2%/}" ;;
		-f|--force-compile) touch_sources; generate_manuals "./.index" ;;
		*)
			if [ "${1:0:1}" = "-" ]
			then
				usage
			else
				analyze_paramters "$1" "$2"
			fi ;;
	esac
fi
